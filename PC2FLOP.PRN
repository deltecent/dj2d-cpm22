

                ;******************************************************************************
                ;
                ;  PC2Flop - Transfer disk image from PC to floppy over serial port.
                ;		(for DISK JOCKEY 2D disk controller)
                ;
                ;	This program writes a soft-sectored 8" floppy with a disk image
                ;	transmitted from a PC. The image is transmitted through the DJ2D
                ;	serial port or an 88-2SIO at I/O address 010h or 12h using the
                ;	XMODEM protocol.
                ;
                ;	The program talks directly to the DJ2D controller and does not
                ;	require CP/M or an OS to function.
                ;
                ;	This program works best if console port and the transfer port
                ;	are not the same device. Otherwise, most error messages won't
                ;	be seen as the file transfer dialog box prevents their display.
                ;
                ;	The program runs standalone at 0x100 or under CP/M. The program
                ;	is exited with a CTRL-C and either warm boots CP/M or just starts
                ;       over when running stand alone.
                ;
                ;	128, 256, 512, and 1024 byte sectors are supported. PC2FLOP will
                ;	determine the sector length by reading the sector length byte
                ;	off tracks 0 and 1. The image being sent from the PC must match
                ;	the format for the disk inserted into the destination drive.
                ;
                ;	Double-sided disks are not supported.
                ;
                ;	Written by Patrick Linstruth based on PC2FLOP for the Tarbell
                ;       controller by Mike Douglas.
                ;
                ;	Rev	 Date	    Desc
                ;	1.0	01/17/21    Original
                ;	1.1	03/02/24    (M. Douglas) Update the sector interleave
                ;			    mechanism and how sectors/track, sector length,
                ;			    and track length are determined.
                ;
                ;*****************************************************************************
                
                ; DISK JOCKEY 2D Prom Address
                
 E000 =         DJBASE	equ	0E000h
 E3F8 =         IOBASE	equ	DJBASE+03f8H
                
                ; Disk information equates
                
 004D =         NUMTRK	equ	77		;number of tracks
 0000 =         MINDRV	equ	0		;first drive number
 0003 =         MAXDRV	equ	3		;max drive number 
                
 0005 =         RDTRIES	equ	5		;number of read (verify) attempts
 0004 =         WRTRIES	equ	4		;number of write attempts
                
                ; Monitor, CP/M boot entry points
                
                MONITOR	set	init		;no monitor, just start over
                CPMBOOT	set	0		;CP/M warm boot jump vector
                
                ; XMODEM equates
                
 0080 =         PKTLEN	equ	128		;128 byte xmodem packet length
 0001 =         SOH	equ	001h
 0004 =         EOT	equ	004h
 0006 =         ACK	equ	006h
 0015 =         NAK	equ	015h
 001A =         EOF	equ	01ah		;ctrl-z character
                
                ; CP/M Equates
                
 0000 =         WBOOT	equ	0		;warm boot jump location
                
                ; Misc equates
                
 000D =         CR	equ	13		;ascii for carriage return
 000A =         LF	equ	10		;ascii for line feed
 007F =         DEL	equ	7fh		;ascii DEL
 0008 =         BS	equ	08h		;ascii backspace
 0003 =         CTRLC	equ	03		;ascii for control-c
 00C3 =         JMPINST	equ	0c3h		;jump instruction opcode
                
 0100           	org	0100h	
                ;-----------------------------------------------------------------------------
                ;  Initialize for transfer
                ;-----------------------------------------------------------------------------
 0100 313B09    init	lxi	sp,ourStk	;initialize stack pointer
 0103 CDD403    	call	chkCpm		;set flag for CP/M or not
 0106 CD1204    	call	sizeRam		;determine amount of RAM available
 0109 CD7507    	call	s2Init		;initialize the 88-2SIO ports
 010C 3E00      	mvi	a,MINDRV	;a=default drive
 010E 32C108    	sta	drvNum		;need for pgmExit
                
                ;  Display welcome message, then get the drive number and port number
                ;    to use for the transfer from the operator.
                
 0111 214304    	lxi	h,mWelcom	;display welcome message
 0114 CD1703    	call	dispMsg
                
                ; getDrv - get drive number or letter from the user.
                
 0117 210E05    getDrv	lxi	h,mDrive	;display drive number prompt
 011A CD1703    	call	dispMsg
 011D CD2203    	call	rcvCon		;get byte from the console
 0120 F620      	ori	20h		;upper case letters to lower case
 0122 FE78      	cpi	'x'		;exit requested?
 0124 CAA203    	jz	pgmExit		;yes
                
 0127 21DA08    	lxi	h,baseDrv	;ascii 1st drive - baseDrv = 0
 012A 96        	sub	m
 012B FE04      	cpi	MAXDRV-MINDRV+1	;validate >=min drive and <= max drive
 012D D21701    	jnc	getDrv		;invalid, prompt again
                
 0130 C600      	adi	MINDRV		;restore offset of 1st drive (if any)
 0132 32C108    	sta	drvNum		;save the drive number to use
                
                ; Restore to track 0, verify drive is not write protected
                
 0135 CDF807    	call	dRestor		;restore to track 0
                
                ; Verify writes?
                
 0138 AF        	xra	a		;clear verify flag
 0139 32CF08    	sta	vfyFlag
                
 013C 214B05    vfyReq	lxi	h,mVerify	;display verify prompt
 013F CD1703    	call	dispMsg
 0142 CD2203    	call	rcvCon		;get byte from the console
 0145 F620      	ori	20h		;upper case letters to lower case
                
 0147 FE6E      	cpi	'n'		;request verify?
 0149 CA5401    	jz	getPort		;no
                
 014C FE79      	cpi	'y'		;request verify?
 014E C23C01    	jnz	vfyReq		;invalid response, retry	
 0151 32CF08    	sta	vfyFlag		;else make vfyFlag non-zero (true)
                
                ; getPort - get serial port number from the user.
                
 0154 216705    getPort	lxi	h,mPort		;display transfer port prompt
 0157 CD1703    	call	dispMsg
 015A CD2203    	call	rcvCon		;get byte from the console
 015D F620      	ori	20h		;upper to lower case, nums not affected
 015F FE78      	cpi	'x'		;exit requested?
 0161 CAA203    	jz	pgmExit		;yes
                
 0164 D631      	sui	'1'		;'1' - '3' to bianry 0-2
 0166 FE03      	cpi	3		;validate ascii 1-3
 0168 D25401    	jnc	getPort		;invalid, prompt again
                
 016B 32D208    	sta	xfrPort		;save the port to use
                
                ; Prompt the user to insert the disk to write, initialize, then start
                ;   sending NAK to start the XMODEM reception.
                
 016E 210406    	lxi	h,mStart	;display start file transfer prompt
 0171 CD1703    	call	dispMsg
                
 0174 AF        	xra	a		;init track we're reading to zero
 0175 32C208    	sta	trkNum
 0178 32D808    	sta	eotFlag		;clear EOT flag
                
 017B 3C        	inr	a		;init xmodem block number to one
 017C 32D308    	sta	blkNum
                
 017F 21000E    	lxi	h,trkBuf	;trkBuf is initial starting point for
 0182 22D608    	shld	rcvPtr		;   XMODEM receive
                
 0185 3E15      	mvi	a,NAK		;send starting nak after purging input data
 0187 CD5003    	call	purgSio
                
                ;-----------------------------------------------------------------------------
                ;  mainLp - Receive as many packets as will fit into RAM and then write
                ;      tracks to disk. Repeat until entire disk is written. 
                ;-----------------------------------------------------------------------------
 018A 3AD808    mainLp	lda	eotFlag		;check for EOT
 018D B7        	ora	a
 018E C2E501    	jnz	allDone		;if EOT, all done
                
 0191 CDF601    	call	bufPkts		;buffer as many packets as possible
 0194 EB        	xchg			;de=start of last packet received
 0195 21000E    	lxi	h,trkBuf	;hl=start of track buffer
 0198 22C908    	shld	trkPtr		;writing will start from here
 019B CD3704    	call	cmpDeHl		;compare last packet start - trkBuf
 019E DAE501    	jc	allDone		;nothing received but an EOT
                
                ; trkLoop - write tracks until all disk tracks have been written or all
                ;    the tracks in the buffer have been written.
                	
 01A1 CD8702    trkLoop	call	wrtTrk		;write a track (hl=next track pointer)
                
 01A4 3AC208    	lda	trkNum		;increment track number
 01A7 3C        	inr	a
 01A8 32C208    	sta	trkNum	
 01AB FE4D      	cpi	NUMTRK		;done all tracks?
 01AD CAE501    	jz	allDone		;yes
                
 01B0 CD1208    	call	dSeek		;seek to next track and read format
                
 01B3 EB        	xchg			;de=next track pointer
 01B4 2AD608    	lhld	rcvPtr		;hl=start of last packet received
 01B7 CD3C04    	call	subHlDe		;hl=hl-de (bytes remaining)
                
 01BA E5        	push	h		;save bytes remaining
 01BB D5        	push	d		;save next track pointer
 01BC EB        	xchg			;de=bytes remaining
 01BD 2AC708    	lhld	trkLen		;hl=track length
 01C0 CD3704    	call	cmpDeHl		;de >= he
 01C3 D1        	pop	d		;de=next track pointer
 01C4 C1        	pop	b		;bc=bytes remaining
 01C5 D2A101    	jnc	trkLoop		;another full track is present
                
                ; If there is an incomplete track remaining in trkBuf, move remaining bytes
                ;     to start of trkBuf and set rcvPtr
                
 01C8 21000E    	lxi	h,trkBuf	;hl=start of trkBuf
 01CB 78        	mov	a,b		;any bytes to move?
 01CC B1        	ora	c		;
 01CD CADA01    	jz	mvDone		;no, skip move
                
 01D0 1A        moveLp	ldax	d		;move from end of trkBuf to start of trkBuf
 01D1 77        	mov	m,a
 01D2 23        	inx	h		;hl->starting bytes of trkBuf
 01D3 13        	inx	d		;de->unwritten bytes from end of trkBuf
 01D4 0B        	dcx	b
 01D5 78        	mov	a,b
 01D6 B1        	ora	c
 01D7 C2D001    	jnz	moveLp
                
 01DA 22D608    mvDone	shld	rcvPtr		;save address where to receive next packet
                
 01DD 3E06      	mvi	a,ACK		;ACK the last packet or EOT
 01DF CD5A03    	call	sndByte
                
 01E2 C38A01    	jmp	mainLp		;go receive more packets
                
                ; allDone - The disk is completely written. ACK the final packet (or EOT),
                ;     display the "transfer complete" message and start the program over.
                
 01E5 3E06      allDone	mvi	a,ACK		;ACK the final packet or EOT
 01E7 CD5A03    	call	sndByte
                
 01EA CDF807    	call	dRestor		;home drive head
                
 01ED 212006    	lxi	h,mDone		;hl->done message
 01F0 CD1703    	call	dispMsg
 01F3 C31701    	jmp	getDrv		;start over asking for drive num
                
                
                ;-----------------------------------------------------------------------------
                ; bufPkts - Receive XMODEM packets until we fill all the track buffer
                ;   space available. Reception starts at the address pointed to by
                ;   rcvPtr. Reception is stopped when trkBuf is full.
                ;   rcvPtr is updated on exit to point to the start of the last packet received.
                ;   The disk write routines use this pointer to know where data ends and
                ;   then update rcvPtr to start to where to begin receiving new packets.
                ;-----------------------------------------------------------------------------
 01F6 CD1C02    bufPkts	call	rcvPkt		;receive a packet
 01F9 EB        	xchg			;de=current xmodem receive pointer
 01FA FE04      	cpi	EOT		;EOT received?
 01FC CA1102    	jz	bufDone		;yes, buffering is done
                
 01FF 2ACD08    	lhld	bufEnd		;hl=end of buffering space
 0202 CD3704    	call	cmpDeHl		;compare current-end	
 0205 D21102    	jnc	bufDone		;past or at end, buffering is done
                
 0208 3E06      	mvi	a,ACK		;otherwise, ACK the packet
 020A CD5A03    	call	sndByte
 020D EB        	xchg			;put xmodem rcv pointer back in HL
 020E C3F601    	jmp	bufPkts		;buffer some more
                
                ; bufDone - no more room for packets. Update rcvPtr to point to the 
                ;   start of the last packet received so the disk write routines know
                ;   where data ends.
                
 0211 EB        bufDone	xchg			;hl=current xmodem receive pointer
 0212 22D608    	shld	rcvPtr		;save use by write tracks
 0215 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; rcvPkt - receive an xmodem format 128 byte packet. HL points to the 128 byte
                ;    buffer to receive. HL is updated by 128 bytes after each succuessful
                ;    reception of a new 128 byte packet.
                ;-----------------------------------------------------------------------------
 0216 E1        nakPkt	pop	h		;get HL back
 0217 3E15      	mvi	a,NAK
 0219 CD5003    	call	purgSio		;purge receive for 1s then transmit NAK
                
                ;wait for SOH or EOT
                
 021C E5        rcvPkt	push	h		;save HL for retries
                
 021D CD9303    waitSoh	call	chkQuit		;check for user abort
 0220 3E03      	mvi	a,3		;3 second timeout for soh
 0222 CD6103    	call	rcvByte		;receive character with timeout
 0225 CA1602    	jz	nakPkt		;timeout
                
 0228 FE01      	cpi	SOH		;SOH received?
 022A CA3702    	jz	haveSoh
                
 022D FE04      	cpi	EOT		;EOT to say we're done?
 022F C21D02    	jnz	waitSoh		;no, keep looking for SOH
 0232 32D808    	sta	eotFlag		;set EOT flag
                
 0235 E1        	pop	h		;undo the entry push
 0236 C9        	ret			;return with EOT
                
                ;  Have SOH, receive block number and not block number
                
 0237 3E01      haveSoh	mvi	a,1		;one second timeout once inside a packet
 0239 CD6103    	call	rcvByte		;get the block number
 023C CA1602    	jz	nakPkt		;timeout, NAK and start over
                
 023F 32D408    	sta	rcvBlk		;save the received block number
 0242 3E01      	mvi	a,1		;one second timeout
 0244 CD6103    	call	rcvByte		;get not block number
 0247 CA1602    	jz	nakPkt		;timeout, NAK and start over
                
 024A 32D508    	sta	rcvNBlk		;save not block number
                
                ;  Receive the 128 byte block
                
 024D 1E00      	mvi	e,0		;init checksum
 024F 1680      	mvi	d,pktLen	;d is byte counter
                
 0251 3E01      pktLoop	mvi	a,1		;one second timeout
 0253 CD6103    	call	rcvByte		;get next data byte
 0256 CA1602    	jz	nakPkt		;timeout
                
 0259 77        	mov	m,a		;store the character
 025A 23        	inx	h		;point to next byte
 025B 83        	add	e		;update the checksum
 025C 5F        	mov	e,a
 025D 15        	dcr	d		;decrement bytes remaining
 025E C25102    	jnz	pktLoop
                
                ;  Verify the checksum
                
 0261 3E01      	mvi	a,1		;one second timeout
 0263 CD6103    	call	rcvByte		;get the checksum
 0266 CA1602    	jz	nakPkt		;timeout
                
 0269 BB        	cmp	e		;checksum match?
 026A C21602    	jnz	nakPkt		;no, packet error
                
                ;  Checksum good. Verify block numbers
                
 026D 3AD508    	lda	rcvNBlk		;verify rcvBlk = not (rcvNBlk)
 0270 2F        	cma			;A should = block number now
 0271 47        	mov	b,a		;save in b
 0272 3AD408    	lda	rcvBlk
 0275 B8        	cmp	b		;compare rcvBlk = not(rcvNBlk)?
 0276 C21602    	jnz	nakPkt		;no, error
                
 0279 3AD308    	lda	blkNum		;compare rcvBlk = expected blkNum
 027C B8        	cmp	b
 027D C21602    	jnz	nakPkt		;nak if not the same (also nak's re-send)
                
 0280 3C        	inr	a		;increment expected block number
 0281 32D308    	sta	blkNum
 0284 C1        	pop	b		;get HL off stack, but don't clobber HL
 0285 AF        	xra	a		;return a zero
 0286 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; wrtTrk - write and verify numSecs sectors to the current track in trkBuf
                ;   as pointed to by trkPtr. After the track is written, trkPtr is updated
                ;   by the length of a track to point to the next track buffer. This
                ;   saved value is also returned in HL.
                ;-----------------------------------------------------------------------------
 0287 3E04      wrtTrk	mvi	a,WRTRIES	;init write retry counter
 0289 32D108    	sta	wrRetry
                
                ; rtryWrt - write a track and the retry entry point.
                
 028C 1EFF      rtryWrt	mvi	e,0FFh		;e=sector number, start at -1
                	
                ; wrtLoop - write a full track starting after the sector in e.
                
 028E CD7708    wrtLoop	call	dNxtSec		;e=sector to write
 0291 CD0603    	call	secOff		;set hl to sector trkPtr offset
 0294 CD4208    	call	dWrite		;write hl to sector e
 0297 C2E702    	jnz	wrtErr		;z clear = write failed
                
 029A 3AC608    	lda	numSecs		;loop for all sectors
 029D BB        	cmp	e
 029E C28E02    	jnz	wrtLoop
                
                ; Verify the track just written
                
 02A1 1EFF      	mvi	e,0FFh		;e=sector number, start at -1
                
 02A3 CD9303    vfyLoop	call	chkQuit		;check for ctrl-c
 02A6 CD7708    	call	dNxtSec		;e=sector to verify
 02A9 213B09    	lxi	h,secBuf	;temporary sector buffer
 02AC CD3F08    	call	dVerify		;verify the sector
 02AF C2C502    	jnz	vfyRtry		;error, go to retry logic
                
 02B2 3AC608    vfyNext	lda	numSecs		;loop for all sectors
 02B5 BB        	cmp	e
 02B6 C2A302    	jnz	vfyLoop
                
                ; Track verified, set up for next track
                
 02B9 2AC708    skipVfy	lhld	trkLen		;get track length
 02BC EB        	xchg			;de = track length
 02BD 2AC908    	lhld	trkPtr		;hl = trkPtr
 02C0 19        	dad	d		;hl = hl + de
 02C1 22C908    	shld	trkPtr		;save start of next track buffer
 02C4 C9        	ret
                
                ; vfyRtry - verify failed, retry reads followed by a re-write
                ;   of the track in needed.
                
 02C5 3E05      vfyRtry	mvi	a,RDTRIES	;init retry counter
 02C7 32D008    	sta	rdRetry
                
 02CA CD9303    retryLp	call	chkQuit		;check for ctrl-c
 02CD 213B09    	lxi	h,secBuf	;hl->temporary sector buffer
 02D0 CD3F08    	call	dVerify		;verify the sector
 02D3 CAB202    	jz	vfyNext		;success, go verify next sector
                
                ; Re-verify failed. Decrement retry count and try again if not zero. Once
                ;   retry counter expires, do another write.
                
 02D6 21D008    	lxi	h,rdRetry	;decrement the read retry counter
 02D9 35        	dcr	m
 02DA C2CA02    	jnz	retryLp		;try again
                
                ; Write verify failed. Decrement the retry count and re-write if the count
                ;    is not zero
                
 02DD 21D108    	lxi	h,wrRetry	;decrement the write retry counter
 02E0 35        	dcr	m
 02E1 C28C02    	jnz	rtryWrt		;retry starting with the write
                
 02E4 C3EA02    	jmp	vfyErr		;display the error and restart
                
                ;-----------------------------------------------------------------------------
                ; Disk write verify failure. Display the track and sector with the error. 
                ;    Restart the program.
                ;-----------------------------------------------------------------------------
 02E7 CD5208    wrtErr	call	dChkErr		;display error
                
 02EA 21A606    vfyErr	lxi	h,errTrk	;hl->where to put ascii decimal
 02ED 3AC208    	lda	trkNum		;a=track with error on it
 02F0 CD7B03    	call	bin2dec		;track to ascii
                
 02F3 21B106    	lxi	h,errSec	;hl->where to put ascii sector
 02F6 7B        	mov	a,e		;a=sector where error occured
 02F7 CD7B03    	call	bin2dec
                
 02FA 218C06    	lxi	h,mDskErr	;display the error message
 02FD CD1703    	call	dispMsg
 0300 313B09    	lxi	sp,ourStk	;initialize stack pointer
 0303 C31701    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; secOff - calculate sector buffer within trkPtr
                ; On Entry:
                ;    trkPtr = start of current track buffer
                ;    secLen = length of sectors in this track
                ;    e = sector number
                ; On Exit:
                ;    hl = sector buffer within trkPtr
                ;    e = sector number
                ; Cobbers:
                ;    a
                ;--------------------------------------------------------------
 0306 7B        secOff  mov	a,e		;a = sector number
 0307 2AC408    	lhld	secLen		;get sector length
 030A 44        	mov	b,h		;bc = sector length
 030B 4D        	mov	c,l
 030C 2AC908    	lhld	trkPtr		;hl = start of curruent track buffer
 030F 3D        	dcr	a		;sector 1?
 0310 C8        	rz			;yes, return
                
 0311 09        secOffL	dad	b		;add sector offset to hl
 0312 3D        	dcr	a		;decrement sector
 0313 C21103    	jnz	secOffL		;loop until done
                
 0316 C9        	ret			;return hl=sector buffer
                
                ;-----------------------------------------------------------------------------
                ; dispMsg - display the null-terminated message passed in hl on the
                ;    console device. Clobbers b, hl
                ;-----------------------------------------------------------------------------
 0317 7E        dispMsg	mov	a,m		;get the next message byte
 0318 B7        	ora	a		;null terminates
 0319 C8        	rz
                
 031A 47        	mov	b,a		;conOut wants character in b
 031B CD9207    	call	conOut
 031E 23        	inx	h		;move to next byte
 031F C31703    	jmp	dispMsg
                
                ;-----------------------------------------------------------------------------
                ; rcvCon - Receive a character from the console device, echo it, then
                ;   wait for a CR. Exits program if Ctrl-c typed. Returns with invalid
                ;   character (null) if BS or DEL pressed after 1st character
                ;   Returns character in a, clobbers b.
                ;-----------------------------------------------------------------------------
 0322 CD8607    rcvCon	call	conIn		;check for input
 0325 CA2203    	jz	rcvCon		;nothing
                
 0328 E67F      	ani	7fh
 032A FE03      	cpi	CTRLC		;abort requested?
 032C CAA203    	jz	pgmExit		;yes
                
 032F FE0D      	cpi	CR		;return pressed?
 0331 C8        	rz			;yes, don't echo it
                
 0332 47        	mov	b,a		;conOut needs character in b
 0333 CD9207    	call	conOut		;echo it
                
                ; Wait for CR, then return 1st character typed
                
 0336 CD8607    rcvCr	call	conIn		;check for input
 0339 CA3603    	jz	rcvCr		;nothing
                
 033C E67F      	ani	7fh
 033E FE03      	cpi	CTRLC		;abort requested?
 0340 CAA203    	jz	pgmExit		;yes
                
 0343 FE7F      	cpi	DEL		;delete
 0345 C8        	rz			;yes, return DEL character
                
 0346 FE08      	cpi	BS		;backspace?
 0348 C8        	rz			;yes, return BS character
                
 0349 FE0D      	cpi	CR		;return pressed?
 034B C23603    	jnz	rcvCr		;no, keep waiting
                
 034E 78        	mov	a,b		;return 1st character typed
 034F C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; purgSio - wait for 1 second of idle time on receive line, then transmit the
                ;	character passed in A (usually ACK or NAK). Clobbers b
                ;-----------------------------------------------------------------------------
 0350 F5        purgSio	push	a
                
 0351 3E01      purge	mvi	a,1		;1 second timeout
 0353 CD6103    	call	rcvByte		;wait for 1 second without activity
 0356 C25103    	jnz	purge
                
 0359 F1        	pop	a		;get back the character to send
                				;fall through to sndByte
                ;-----------------------------------------------------------------------------
                ; sndByte - send the byte in a through the specified transfer port. 
                ;     Clobbers b. (assuming serOut clobbers only a).
                ;-----------------------------------------------------------------------------
 035A 47        sndByte	mov	b,a		;b=byte to transmit
 035B 3AD208    	lda	xfrPort		;a=port to use for transfer
 035E C3C407    	jmp	serOut		;send the character
                
                
                ;-----------------------------------------------------------------------------
                ; rcvByte - Receive a byte from the specified transfer port. A wait timeout
                ;     in seconds is specified in a. If a timeout occurs, zero is returned in
                ;     a and the zero flag is true. Otherwise, the character is returned in a 
                ;     (could be zero) and the zero flag is false. ONESEC must be set based
                ;     on processor speed and the number of cycles in the serIn call + 59.
                ;     Clobbers a, b and c.
                ;-----------------------------------------------------------------------------
 0361 D5        rcvByte	push	d		;save d, e
 0362 57        	mov	d,a		;save timeout in d
                
 0363 011F4B    initSec	lxi	b,ONESEC	;one second timeout 104 cycles per loop
                
 0366 3AD208    rcvWait	lda	xfrPort		;(13) a=port to use for transfer
 0369 CDA107    	call	serIn		;(17+45) look for a byte
 036C C27903    	jnz	haveChr		;(10) byte received
                
 036F 0B        	dcx	b		;(5) otherwise, decrement timer
 0370 78        	mov	a,b		;(5) one second expire?
 0371 B1        	ora	c		;(4)
 0372 C26603    	jnz	rcvWait		;(10) no, keep waiting
                
                ; one second timeout has occured. Decrement the seconds counter.
                
 0375 15        	dcr	d		;decrement seconds counter
 0376 C26303    	jnz	initSec		;initialize for another 1 second count
 0379 D1        haveChr	pop	d		;restore d, e
 037A C9        	ret
                
                
                ;--------------------------------------------------------------
                ; bin2dec - Binary byte in A to 2 ASCII digits at (HL)
                ;   HL is preserved
                ;--------------------------------------------------------------
 037B 3620      bin2dec	mvi	m,' '		;assume zero supression
 037D D60A      	sui	10		;value less than 10?
 037F DA8D03    	jc	do1s		;yes, leading blank
 0382 3631      	mvi	m,'1'		;have one ten already
                
 0384 D60A      loop10	sui	10		;count 10s
 0386 DA8D03    	jc	do1s		;done with 10s, do 1s
 0389 34        	inr	m
 038A C38403    	jmp	loop10
                
 038D C63A      do1s	adi	'0'+10		;form ASCII 1s digit
 038F 23        	inx	h		;move to 1s position
 0390 77        	mov	m,a
 0391 2B        	dcx	h		;restore hl
 0392 C9        	ret
                
                ;--------------------------------------------------------------
                ; chkQuit - check for the user to request abort (ctrl-c). If
                ;    a character is present on the console port, read it and
                ;    see if ctrl-c. Clobbers A
                ;--------------------------------------------------------------
 0393 CD8607    chkQuit	call	conIn		;check for console input
 0396 C8        	rz
                
 0397 E67F      chkCtlc	ani	7fh
 0399 FE03      	cpi	CTRLC		;abort requested?
 039B C0        	rnz			;no
                
                ; Ctrl-C typed while program is running. Return to drive prompt.
                
 039C 313B09    	lxi	sp,ourStk	;initialize stack pointer
 039F C31701    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; pgmExit - Exit to CP/M or to the monitor ROM based on the
                ;    CP/M flag
                ;--------------------------------------------------------------
 03A2 3AD908    pgmExit	lda	cpmFlag		;running under CP/M?
 03A5 B7        	ora	a
 03A6 C2B203    	jnz	cpmExit		;yes
                
                ; Exit to ROM monitor
                
 03A9 212B07    	lxi	h,mExit		;display "exiting" message
 03AC CD1703    	call	dispMsg
 03AF C30001    	jmp	MONITOR		;jump to ROM monitor entry point
                
                ; CP/M exit. If boot drive was used, prompt user to insert CP/M disk
                
 03B2 3AC108    cpmExit	lda	drvNum		;boot drive used?
 03B5 D600      	sui	MINDRV
 03B7 C2C303    	jnz	noDisk		;not 1, disk prompt not needed
                
 03BA 213B07    	lxi	h,mCpm		;display "insert cp/m disk"	
 03BD CD1703    	call	dispMsg
 03C0 CD2203    	call	rcvCon		;wait for a character
                
 03C3 3E00      noDisk	mvi	a,MINDRV	;re-select drive A for CP/M 1.4
 03C5 32C108    	sta	drvNum
 03C8 CDF007    	call	dSelDrv
                
 03CB 212B07    	lxi	h,mExit		;display "exiting" message
 03CE CD1703    	call	dispMsg
 03D1 C30000    	jmp	CPMBOOT		;reboot CP/M
                
                ;--------------------------------------------------------------
                ; chkCpm - check if running under CP/M. CP/M flag is set true
                ;   (non-zero) if yes, cleared otherwise.
                ;--------------------------------------------------------------
                ; First, initialize entries for stand-alone
                
 03D4 AF        chkCpm	xra	a
 03D5 32D908    	sta	cpmFlag		;clear CP/M flag
 03D8 3E30      	mvi	a,MINDRV+'0'	;ascii for minimum drive number
 03DA 323705    	sta	mDrvMin		;store in the drive prompt message
 03DD 32DA08    	sta	baseDrv		;ascii 1st drive - baseDrv = 0
 03E0 3E33      	mvi	a,MAXDRV+'0'	;ascii for max drive number
 03E2 323905    	sta	mDrvMax
                
                ; Determine if we're under CP/M or standalone. CP/M is assumed if
                ;   a jump instruction is present at the CP/M warm start location (0)
                ;   and five more jumps (e.g., a jump table) is present at the
                ;   jump-to destination.
                		
 03E5 3A0000    	lda	WBOOT		;see if jump instruction present for CP/M
 03E8 FEC3      	cpi	JMPINST
 03EA C0        	rnz			;no, not CP/M
                
                ; A jump instruction is present at the CP/M warm boot location (0),
                ;   now see if that jump points to five more jumps. If so, assume CP/M
                
 03EB 210100    	lxi	h,WBOOT+1	;point to lsb of jump address
 03EE 5E        	mov	e,m		;e=low byte of jump
 03EF 23        	inx	h
 03F0 56        	mov	d,m		;de=destination of jump
 03F1 0605      	mvi	b,5		;look for 5 more jumps (a jump table)
                
 03F3 1A        jmpTest	ldax	d		;a=opcode at jump destination
 03F4 D6C3      	sui	JMPINST		;another jump present?
 03F6 C0        	rnz			;no, not CP/M
                
 03F7 13        	inx	d		;move to next jump
 03F8 13        	inx	d
 03F9 13        	inx	d
 03FA 05        	dcr	b
 03FB C2F303    	jnz	jmpTest
                
 03FE 3D        	dcr	a		;a=0ffh
 03FF 32D908    	sta	cpmFlag		;CP/M flag to non-zero = true
                
                ; We're running under CP/M. Change drive prompt message to show drive
                ;    letters instead of drive numbers and change baseDrv to convert
                ;    an 'A' to the base drive number (MINDRV).
                
 0402 3E41      	mvi	a,'A'		;'A' in drive message instead of number
 0404 323705    	sta	mDrvMin
 0407 C603      	adi	MAXDRV-MINDRV	;max drive letter
 0409 323905    	sta	mDrvMax
 040C 3E61      	mvi	a,'a'		;ascii 1st drive - baseDrv = 0
 040E 32DA08    	sta	baseDrv
 0411 C9        	ret
                
                ;------------------------------------------------------------------
                ; sizeRam - determine how much RAM we have for buffering tracks.
                ;   Sets the bufEnd variable which points to end address of 
                ;   the last possible track buffer + 1
                ;------------------------------------------------------------------
                ; If running under CP/M, use the BIOS pointer to determine the top
                ;    of available RAM. Otherwise, size RAM manually.
                
 0412 2A0100    sizeRam	lhld	WBOOT+1		;get address of BIOS jump table+3
 0415 2B        	dcx	h		
 0416 2B        	dcx	h
 0417 2B        	dcx	h		;hl->top of usable ram+1
 0418 3AD908    	lda	cpmFlag		;running under CP/M?
 041B B7        	ora	a
 041C C22D04    	jnz	ramEnd		;yes, we have the end of RAM
                
                ;  Not under CP/M. Find the end of RAM manually.
                
 041F 21000E    	lxi	h,(trkBuf+0ffh) AND 0ff00h   ;next 256 byte boundary
                
 0422 7E        ramLoop	mov	a,m		;a=current RAM content
 0423 34        	inr	m		;change RAM
 0424 BE        	cmp	m		;did RAM change?
 0425 77        	mov	m,a		;restore RAM
 0426 CA2D04    	jz	ramEnd		;end of RAM found
                
 0429 24        	inr	h		;next page
 042A C22204    	jnz	ramLoop
                
                ; ramEnd - end of RAM found. Subtract 256 bytes because it seems
                ;   like a good idea.
                
 042D 25        ramEnd	dcr	h		;hl=end of RAM + 1
 042E 22CD08    	shld	bufEnd		;save as bufEnd
 0431 C9        	ret
                
                ;--------------------------------------------------------------------
                ; cmHlDe - compare HL-DE. Carry set if HL<DE, carry clear if HL>=DE
                ;--------------------------------------------------------------------
 0432 7D        cmpHlDe	mov	a,l		;compare HL-DE, do lsbs first
 0433 93        	sub	e
 0434 7C        	mov	a,h		;do msbs
 0435 9A        	sbb	d
 0436 C9        	ret			;carry set HL<DE, clear HL>=DE
                
                ;--------------------------------------------------------------------
                ; cmDeHl - compare DE-HL. Carry set if DE<HL, carry clear if DE>=HL
                ;--------------------------------------------------------------------
 0437 7B        cmpDeHl	mov	a,e		;compare DE-HL, do lsbs first
 0438 95        	sub	l
 0439 7A        	mov	a,d		;do msbs
 043A 9C        	sbb	h
 043B C9        	ret			;carry set DE<HL, clear DE>=HL
                
                ;--------------------------------------------------------------------
                ; subHlDe - HL=HL-DE
                ;--------------------------------------------------------------------
 043C 7D        subHlDe	mov	a,l		;subtract HL-DE, do lsbs first
 043D 93        	sub	e
 043E 6F        	mov	l,a		;lsb result in l
 043F 7C        	mov	a,h		;do msbs
 0440 9A        	sbb	d
 0441 67        	mov	h,a		;msb result in h	
 0442 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ;   Data Area
                ;-----------------------------------------------------------------------------
 0443 0D0A0A    mWelcom	db	cr,lf,lf
 0446 3D3D3D3D3D	db 	'===== PC to Floppy Disk Image Transfer =====',cr,lf
 0474 2020202020	db	'      (DJ2D Controller @ E000, ver 1.1)',cr,lf,lf
 049E 5772697465	db	'Writes an 8" floppy with a disk imaged received via the'
 04D5 0D0A      	db	cr,lf
 04D7 444A324420	db	'DJ2D or 88-2SIO serial port using the XMODEM protocol.',0
                
 050E 0D0A0A496EmDrive	db	cr,lf,lf,'Insert and specify destination drive ('
 0537 782D      mDrvMin	db	'x-'
 0539 7829206F72mDrvMax	db	'x) or X to exit: ',0
                
 054B 0D0A0A    mVerify	db	cr,lf,lf
 054E 5665726966	db	'Verify writes (Y or N)? ', 0
                
 0567 0D0A0A    mPort	db	cr,lf,lf
 056A 5370656369	db	'Specify the port to use for file transfer',cr,lf
 0595 2020312920	db	'  1) DJ2D (which is also the console port)',cr,lf
 05C1 2020322920	db	'  2) 88-2SIO port A',cr,lf
 05D6 2020332920	db	'  3) 88-2SIO port B',cr,lf
 05EB 456E746572	db	'Enter 1-3 or X to exit: ',0
                
 0604 0D0A0A    mStart	db	cr,lf,lf
 0607 5374617274	db	'Start XMODEM send now...',0
                
 0620 0D0A0A4372mDone	db	cr,lf,lf,'Creation of new disk successful!',cr,lf,0
                
 0646 0D0A0A5365mNoTrk0	db	cr,lf,lf,'Seek to track 0 failed',cr,lf,0
                
 0662 0D0A0A5365mNoSec	db	cr,lf,lf,'Sector not found - disk not formatted?',0
                
 068C 0D0A0A5772mDskErr	db	cr,lf,lf,'Write failure on track '
 06A6 78782C2073errTrk	db	'xx, sector '
 06B1 78782E2044errSec	db	'xx. Disk creation aborted.',cr,lf,0
                
 06CE 0D0A0A4472mNotRdy	db	cr,lf,lf,'Drive is not ready',cr,lf,0
 06E6 0D0A0A4469mWrtPrt	db	cr,lf,lf,'Disk is write protected',cr,lf,0
 0703 0D0A0A4352mCrcErr	db	cr,lf,lf,'CRC error',cr,lf,0
 0712 0D0A0A556EmUnkErr	db	cr,lf,lf,'Unknown write error',cr,lf,0
                
 072B 0D0A0A4578mExit	db	cr,lf,lf,'Exiting...',cr,lf,0
                
 073B 0D0A0A    mCpm	db	cr,lf,lf
 073E 496E736572	db	'Insert CP/M disk into drive A, then press Return...',0
                
 0772 0D0A00    mCrLf	db	cr,lf,0
                
                
                ;****************************************************************************
                ;
                ;  Hardware specific console and serial I/O routines. 
                ;     The following four routines must be written to provide a common
                ;     interface to the hardware on which this program is running. The
                ;     port number specified for serIn and serOut matches the port number
                ;     input from the operator via the port menu.
                ;
                ;****************************************************************************
                
                ; DJ2D Serial Port Equates
                
 E3F8 =         djDat	equ	IOBASE+0
 E3F9 =         djCtl	equ	IOBASE+1
 0004 =         djDr	equ	004h		;data ready flag
 0008 =         djTbre	equ	008h		;transmit buffer register empty flag
                
                ; 88-2SIO Serial Board Equates
                
 0010 =         s2aCtl	equ	010h		;1st port on 88-2SIO board - control register
 0011 =         s2aDat	equ	011h		;1st port on 88-2SIO board - data register
 0012 =         s2bCtl	equ	012h		;2nd port on 88-2SIO board - control register
 0013 =         s2bDat	equ	013h		;2nd port on 88-2SIO board - data register
 0001 =         s2Rdrf	equ	001h		;read data register full flag
 0002 =         s2Tdre	equ	002h		;transmit data register empty flag
 0003 =         s2Rst	equ	003h		;reset command
 0015 =         s28n1	equ	015h		;8N1 selection
 0011 =         s28n2	equ	011h		;8N2 selection
                
                ; 88-SIO Serial board Equates
                
 0000 =         sioCtl	equ	00h		;control port
 0001 =         sioDat	equ	01h		;data port
 0001 =         sioRdrf	equ	00000001b	;-RX Data register full
 0080 =         sioTdre	equ	10000000b	;-TX Data register empty
                
                ; The rcvByte subroutine above times a one second timeout with a code
                ;    loop that calls the hardware specific serIn routine below. ONESEC
                ;    must be set based on processor speed and the number of cycles in 
                ;    the serIn call + 59 cycles for the rcvByte code. 
                
 4B1F =         ONESEC	equ	19231		;rcvByte loop count for 1 second
                
                ;----------------------------------------------------------------------------
                ; s2Init - reset and initialize 88-2SIO ports for 8N1
                ;----------------------------------------------------------------------------
 0775 3E03      s2Init	mvi	a,s2Rst		;reset and init 1st 88-2SIO port
 0777 D310      	out	s2aCtl
 0779 3E15      	mvi	a,s28n1		;transfer port as 8N1
 077B D310      	out	s2aCtl
                
 077D 3E03      	mvi	a,s2Rst		;reset and init 2nd 88-2SIO port
 077F D312      	out	s2bCtl
 0781 3E15      	mvi	a,s28n1		;transfer port as 8N1
 0783 D312      	out	s2bCtl
 0785 C9        	ret	
                
                ;----------------------------------------------------------------------------
                ; conIn - input character from console
                ;    inputs:
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ;    clobbers none
                ;----------------------------------------------------------------------------
 0786 3AF9E3    conIn	lda	djCtl		;see if a new character is present
 0789 2F        	cma			;status is inverted
 078A E604      	ani	djDr
 078C C8        	rz			;no character, return zero status
                
 078D 3AF8E3    	lda	djDat		;return character and non-zero status
 0790 2F        	cma			;byte is inverted
 0791 C9        	ret	
                
                ;----------------------------------------------------------------------------
                ; conOut - output character to console
                ;    inputs: b = character to send
                ;    clobbers a
                ;----------------------------------------------------------------------------
 0792 3AF9E3    conOut	lda	djCtl		;wait for OK to transmit
 0795 2F        	cma			;status is inverted
 0796 E608      	ani	djTbre
 0798 CA9207    	jz	conOut
 079B 78        	mov	a,b		;a=character to transmit
 079C 2F        	cma			;byte is inverted
 079D 32F8E3    	sta	djDat		;send it
 07A0 C9        	ret
                
                ;----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serIn - input character from port specified in a
                ;       0 = DJ2D
                ;       1 = 88-2SIO port A
                ;       2 = 88-2SIO port B
                ;    inputs: a = port to read from
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ;    clobbers none
                ; 88-2SIO Port A: 53 cycles including return when no character present
                ; 88-2SIO Port B: 43 cycles including return when no character present
                ;-----------------------------------------------------------------------------
 07A1 3D        serIn	dcr	a		;(5)3-way test
 07A2 CAB407    	jz	s2InA		;(10)a was 1: 88-2SIO port A
 07A5 F2BC07    	jp	s2InB		;(10)a was 2: 88-2SIO port B
                				;    a was 0: DJ2D
                ; Input from DJ2D
 07A8 3AF9E3    djIn	lda	djCtl		;see if a new character is present
 07AB 2F        	cma			;status is inverted
 07AC E604      	ani	djDr
 07AE C8        	rz			;no character, return zero status
                
 07AF 3AF8E3    	lda	djDat		;return character and non-zero status
 07B2 2F        	cma			;byte is inverted
 07B3 C9        	ret	
                
                ; Input from 88-2SIO port A
                
 07B4 DB10      s2InA	in	s2aCtl		;(10+1)see if a new character is present
 07B6 E601      	ani	s2Rdrf		;(7)
 07B8 C8        	rz			;(10)no character, return zero status
 07B9 DB11      	in	s2aDat		;return character and non-zero status
 07BB C9        	ret	
                	
                ; Input from 88-2SIO port B
                
 07BC DB12      s2InB	in	s2bCtl		;(10+1)see if a new character is present
 07BE E601      	ani	s2Rdrf		;(7)
 07C0 C8        	rz			;(10)no character, return zero status
                
 07C1 DB13      	in	s2bDat		;return character and non-zero status
 07C3 C9        	ret	
                
                ;-----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serOut - output character to port specified in a
                ;       0 = 88-2SIO port A
                ;       1 = 88-2SIO port B
                ;       2 = 88-SIO
                ;    inputs: a = port to transmit through
                ;	     b = character to send
                ;    clobbers a
                ;-----------------------------------------------------------------------------
 07C4 3D        serOut	dcr	a		;3-way test
 07C5 CADA07    	jz	s2OutA		;a was 1: 88-2SIO port A
 07C8 F2E507    	jp	s2OutB		;a was 2: 88-2SIO port B
                				;a was 0: DJ2D
                ; Send character through DJ2D
                
 07CB 3AF9E3    djOut	lda	djCtl		;wait for OK to transmit
 07CE 2F        	cma			;status is inverted
 07CF E608      	ani	djTbre
 07D1 CACB07    	jz	djOut
 07D4 78        	mov	a,b		;a=character to transmit
 07D5 2F        	cma			;byte is inverted
 07D6 32F8E3    	sta	djDat		;send it
 07D9 C9        	ret
                
                ; Send character through 88-2SIO port A
                
 07DA DB10      S2OutA	in	s2aCtl		;wait for OK to transmit
 07DC E602      	ani	s2Tdre
 07DE CADA07    	jz	S2OutA
                
 07E1 78        	mov	a,b		;a=character to transmit
 07E2 D311      	out	s2aDat		;send it
 07E4 C9        	ret
                
                ; Send character through 88-2SIO port B
                
 07E5 DB12      s2OutB	in	s2bCtl		;wait for OK to transmit
 07E7 E602      	ani	s2Tdre
 07E9 CAE507    	jz	s2OutB
                
 07EC 78        	mov	a,b		;a=character to transmit
 07ED D313      	out	s2bDat		;send it
 07EF C9        	ret
                
                ;****************************************************************************
                ;
                ; DJ2D disk I/O routines
                ;
                ;****************************************************************************
                
 E000 =         DBOOT	equ	DJBASE		;DOS bootstrap routine
 E003 =         TERMIN	equ	DJBASE+003H	;serial input
 E006 =         TRMOUT	equ	DJBASE+006H	;serial output
 E009 =         TKZERO	equ	DJBASE+009H	;recalibrate (seek to TRK0)
 E00C =         TRKSET	equ	DJBASE+00CH	;seek
 E00F =         SETSEC	equ	DJBASE+00FH	;select sector
 E012 =         SETDMA	equ	DJBASE+012H	;set DMA address
 E015 =         READ	equ	DJBASE+015H	;read a sector of disk data
 E018 =         WRITE	equ	DJBASE+018H	;write a sector of disk data
 E01B =         SELDRV	equ	DJBASE+01BH	;select a disk drive
 E01E =         TPANIC	equ	DJBASE+01EH	;test for panic character
 E021 =         TSTAT	equ	DJBASE+021H	;serial status input
 E024 =         DMAST	equ	DJBASE+024H	;read current DMA address
 E027 =         STATUS	equ	DJBASE+027H	;disk status input
 E02A =         DSKERR	equ	DJBASE+02AH	;loop to strobe error LED
 E02D =         SETDEN	equ	DJBASE+02DH	;set density
 E030 =         SETSID	equ	DJBASE+030H	;set side for 2-headed drives
                
                ;--------------------------------------------------------------
                ; dSelDrv - Select drive specified in drvNum 
                ; On Entry:
                ;    drvNum = drive to be selected
                ; On Exit:
                ;    drive selected
                ; Clobbers c
                ;--------------------------------------------------------------
 07F0 3AC108    dSelDrv	lda	drvNum		;a=desired drive
 07F3 4F        	mov	c,a
 07F4 CD1BE0    	call	SELDRV
 07F7 C9        	ret
                
                ;--------------------------------------------------------------
                ; dRestor - Selects drive, loads heads and restores to track 0.
                ;    If restore fails, message display and program restarted
                ;    at getDrv.
                ; On Entry:
                ;    drvNum = drive to be selected and restored to track zero
                ; On Exit:
                ;    drive selected and on track zero
                ; Clobbers none 
                ;--------------------------------------------------------------
 07F8 CDF007    dRestor	call	dSelDrv		;make sure drive is selected
 07FB CD09E0    	call	TKZERO
 07FE CD27E0    	call	STATUS
 0801 79        	mov	a,c		;get track number
 0802 B7        	ora	a		;track 0?
 0803 CA8508    	jz	dScFmtA		;yes, set sector data and exit
                
                ; restore failed
                
 0806 214606    	lxi	h,mNoTrk0
                
 0809 CD1703    errMsg	call	dispMsg
 080C 313B09    	lxi	sp,ourStk	;initialize stack pointer
 080F C31701    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; dSeek - Seek track specified in A. If track is 0 or 1, read
                ;    sector 1 to and determine format.
                ; On Entry:
                ;    a = desired track
                ; On Exit:
                ;    secFmt - sector length (0-3)
                ;    numSecs - sectors per track (26,26,15,8)
                ;    secLen - sector length (128,256,512,1024)
                ;    trkLen - numSecs * secLen
                ;    C flag clear = good, C flag set = error
                ; Clobbers c
                ;--------------------------------------------------------------
 0812 E5        dSeek	push	h		;save hl
 0813 D5        	push	d		;save de
                
 0814 6F        	mov	l,a
                
 0815 CDF007    	call	dSelDrv		;make sure drive is selected
                
 0818 4D        	mov	c,l		;track to c
 0819 CD0CE0    	call	TRKSET		;set track
 081C FE02      	cpi	2
 081E D22C08    	jnc	dSeekRt		;return if track > 1
                
 0821 213B09    	lxi	h,secBuf	;temporary sector buffer
 0824 1E01      	mvi	e,1
 0826 CD2F08    	call	dRead		;read to update status
 0829 CD8108    	call	dSecFmt		;get track's sector format
                
 082C D1        dSeekRt	pop	d		;restore hl
 082D E1        	pop	h		;restore de
 082E C9        	ret
                
                ;--------------------------------------------------------------
                ; dRead - Read sector on current track.
                ; On Entry:
                ;    Drive is selected, on proper track
                ;    hl->sector buffer
                ;    e = sector number to read
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;    clobbers b,c,h,l
                ;--------------------------------------------------------------
 082F D5        dRead	push	d		;save de
 0830 4B        	mov	c,e		;sector number in c
 0831 CD0FE0    	call	SETSEC		;set sector
 0834 44        	mov	b,h		;bc = hl
 0835 4D        	mov	c,l
 0836 CD12E0    	call	SETDMA
 0839 CD15E0    	call	READ
                
 083C B7        	ora	a		;update zero flag
                
 083D D1        	pop	d		;restore de
 083E C9        	ret
                
                ;--------------------------------------------------------------
                ; dVerify - Verify sector on current track. The DJ2D PROM does
                ;    not provide a verify command, so we just read the sector.
                ; On Entry:
                ;    Drive is selected, on proper track
                ;    hl->sector buffer
                ;    e = sector number to verify
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;    clobbers none
                ;--------------------------------------------------------------
 083F C32F08    dVerify	jmp	dRead		;verify the sector
                
                
                ;--------------------------------------------------------------
                ; dWrite - Write a sector on current track
                ; On Entry:
                ;    Drive is selected, on proper track, head loaded
                ;    hl->buffer address
                ;    e = sector number to write
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;   clobbers h,l
                ;--------------------------------------------------------------
 0842 D5        dWrite	push	d		;save de
 0843 4B        	mov	c,e		;sector number in c
 0844 CD0FE0    	call	SETSEC		;set sector
 0847 44        	mov	b,h		;bc = hl
 0848 4D        	mov	c,l
 0849 CD12E0    	call	SETDMA
 084C CD18E0    	call	WRITE
 084F D1        	pop	d		;restore de
 0850 B7        	ora	a		;update zero flag
                
 0851 C9        	ret
                
                ;--------------------------------------------------------------
                ; dChkErr - check error status bits
                ; On Entry:
                ;    a = DJ2D error bits
                ; On Exit:
                ;    returns if no error. Otherwise, an error
                ;    message is displayed and the program starts over.
                ; Clobbers none
                ;--------------------------------------------------------------
 0852 B7        dChkErr	ora	a		;test for error
 0853 C8        	rz			;return if no error
                
 0854 21CE06    	lxi	h,mNotRdy	;not ready message
 0857 17        	ral			;not ready bit?
 0858 DA0908    	jc	errMsg		;no, check next bit
                
 085B 21E606    	lxi	h,mWrtPrt	;write protect messages
 085E 17        	ral			;write protect bit?
 085F DA0908    	jc	errMsg		;no, check next bit
                
 0862 216206    	lxi	h,mNoSec	;sector not found message
 0865 17        	ral			;unused bit
 0866 17        	ral			;write protect bit?
 0867 DA0908    	jc	errMsg		;no, check next bit
                
 086A 210307    	lxi	h,mCrcErr	;CRC error message
 086D 17        	ral			;CRC error bit?
 086E DA0908    	jc	errMsg		;no, check next bit
                
 0871 211207    	lxi	h,mUnkErr	;Unknown error message
 0874 C30908    	jmp	errMsg
                
                ;--------------------------------------------------------------
                ; dNextSec - Move to next sector. Reads odd sectors first
                ;    then even sectors. Very first call for a track should
                ;    have sector -1 in e.
                ; On Entry:
                ;    e = last sector read 
                ; On Exit:
                ;    e = new sector to read
                ; Clobbers e
                ;--------------------------------------------------------------
 0877 1C        dNxtSec	inr	e		;read every other sector
 0878 1C        	inr	e
 0879 3AC608    	lda	numSecs		;past end?
 087C BB        	cmp	e
 087D D0        	rnc			;no
                
 087E 1E02      	mvi	e,2		;else, do even sectors
 0880 C9        	ret
                
                ;--------------------------------------------------------------
                ; dSecFmt - Set sectors per track, sector length, and track
                ;    length from the most recent sector read.
                ;
                ; dScFmtA - Status already in A
                ;
                ; On Entry:
                ;    drive selected
                ; On Exit:
                ;    numSecs - sectors per track (26,26,15,8)
                ;    secLen - sector length (128,256,512,1024)
                ;    trkLen - track length
                ;--------------------------------------------------------------
 0881 CD27E0    dSecFmt	call	STATUS
 0884 1F        	rar			;sector length is bits 2-3
 0885 E606      dScFmtA	ani	06h		;a=2*length code
 0887 1600      	mvi	d,0		;de=2*length code (16 bit)
 0889 5F        	mov	e,a
                
 088A 21A908    	lxi	h,sptTbl	;set sectors per track
 088D 19        	dad	d		;index by length code
 088E 7E        	mov	a,m
 088F 32C608    	sta	numSecs
                 
 0892 21B108    	lxi	h,seclTbl	;set sector length
 0895 19        	dad	d		;index by length code
 0896 4E        	mov	c,m		;lsb
 0897 23        	inx	h
 0898 66        	mov	h,m		;msb
 0899 69        	mov	l,c		;hl=sector length
 089A 22C408    	shld	secLen
                
 089D 21B908    	lxi	h,trklTbl	;set track length
 08A0 19        	dad	d		;index by length code
 08A1 4E        	mov	c,m		;lsb
 08A2 23        	inx	h
 08A3 66        	mov	h,m		;msb
 08A4 69        	mov	l,c		;hl=track length
 08A5 22C708    	shld	trkLen
 08A8 C9        	ret
                
 08A9 1A001A000FsptTbl	dw	26, 26, 15, 8
 08B1 8000000100seclTbl	dw	128, 256, 512, 1024
 08B9 000D001A00trklTbl	dw	26*128, 26*256, 15*512, 8*1024
                
                ;**************************************************************************
                ; 
                ;  Data area
                ;
                ;**************************************************************************
                ; Disk variables
                
 08C1           drvNum	ds	1		;drive number to use
 08C2           trkNum	ds	1		;track number to read
 08C3           secFmt	ds	1		;0=128,1=256,2=512,3=1024
 08C4           secLen	ds	2		;sector length
 08C6           numSecs	ds	1		;number of sectors per track
 08C7           trkLen	ds	2		;track length
 08C9           trkPtr	ds	2		;pointer into trkBuf
 08CB           skewPtr	ds	2		;pointer to skew table
 08CD           bufEnd	ds	2		;end address + 1 of last track spot in RAM
                
                ; Retry logic variables
                
 08CF           vfyFlag	ds	1		;verify writes flag
 08D0           rdRetry	ds	1		;disk read retry counter
 08D1           wrRetry	ds	1		;disk write retry counter
                
                ; Xmodem variables
                
 08D2           xfrPort	ds	1		;pseudo port for file transfer
 08D3           blkNum	ds	1		;current xmodem block number
 08D4           rcvBlk	ds	1		;block number received
 08D5           rcvNBlk	ds	1		;"not" block number received
 08D6           rcvPtr	ds	2		;pointer for start of XMODEM send
 08D8           eotFlag	ds	1		;EOT received flag
                
                ; Misc variables
                
 08D9           cpmFlag	ds	1		;non-zero if running under CP/M
 08DA           baseDrv	ds	1		;ascii 1st drive - baseDrv = 0
 08DB           	ds	96		;stack space
 093B =         ourStk	equ	$
                
                ; Temporary sector buffer
                
 093B           secBuf	ds	1024
                
                ; Track buffer runs from here to the end of memory
                ; Put on page boundary for easier debugging
                
 0E00 =         trkBuf	equ	($+0100h) and 0ff00h
                
 0D3B           	end
