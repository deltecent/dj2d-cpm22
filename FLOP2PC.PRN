

                ;*****************************************************************************
                ;
                ;  Flop2PC - Transfer floppy image to PC over a serial port
                ;		(for DISK JOCKEY 2D disk controller)
                ;
                ;	This program transmits an image of a soft-sectored 8" floppy
                ;	to a PC. The image is transmitted through a DISK JOCKEY 2D with the
                ;       PROM at address E000, or a 88-2SIO at I/O address 010h or 012h
                ;       using the XMODEM protocol.
                ;
                ;	The program talks directly to the DJ2D controller and does not require
                ;	CP/M or an OS to function.
                ;
                ;	This program works best if the console port and the transfer port
                ;	are not the same device. Otherwise, most error messages won't
                ;	be seen as the file transfer dialog box prevents their display.
                ;
                ;	The program runs standalone at 0x100 or under CP/M. The program
                ;	is exited with a CTRL-C and either warm boots CP/M or just starts
                ;       over when running stand alone.
                ;
                ;	128, 256, 512, and 1024 byte sectors are supported. FLOP2PC will
                ;	determine the sector length by reading the sector length byte
                ;	from tracks 0 and 1.
                ;
                ;	Double-sided disks are not supported.
                ;
                ;	Written by Patrick Linstruth based on FLOP2PC for the Tarbell
                ;       controller by Mike Douglas.
                ;
                ;	Rev	 Date	    Desc
                ;	1.0	01/15/21    Original
                ;	1.1	03/02/24    (M. Douglas) Add retries to track read loop,
                ;			    update the sector interleave mechanism and
                ;			    how sectors/track, sector length, and track
                ;			    length are determined.
                ;
                ; FLOP2PC first allocates a track buffer by searching for the top of
                ; memory. The track buffer starts at trkBuf and ends at bufEnd.
                ; When running under CP/M the top is memory is determined by the
                ; start of the BIOS.
                ;
                ; mainLp is the main loop that reads tracks from disk into trkBuf
                ; with readTrk. The DJ2D supports different sector sizes. When
                ; seeking to tracks 0 and 1, sector 1 is read to determine the
                ; sector length, sectors per track, and track length. The DJ2D
                ; firmware does not provide a 1791 READ ADDRESS function, so the
                ; sector is actually read.
                ;
                ; readTrk reads all the sectors of the track into trkBuf pointed
                ; to by trkPtr. After all sectors are read, trkPtr points to the
                ; end of track data + 1.
                ;
                ; When trkBuf will not fit another complete track, sndTrks
                ; sends trkBuf up to trkPtr in 128 byte packets using
                ; the Xmodem protocol. When all packets have been sent,
                ; mainLp reads the next tracks into trkBuf until all tracks
                ; have been read and sent.
                ;
                ;
                ;                          ************
                ;                          *  trkBuf  *
                ;                          ************
                ; sndPtr increased by +--> *  TRK X   * <--+ trkPtr is increased by
                ;    length of packet |    ************    | trkLen as tracks are
                ; as packets are sent +--> *  TRK X+1 * <--+ read from disk
                ;         over Xmodem |    ************    |
                ;                     |    * ........ *    |
                ;                     v    * ........ *    v
                ;                          * ........ *
                ;                          ************
                ;                          *  TRK X+n *
                ;                          ************
                ;                          *  bufEnd  * <--- Tracks are read until
                ;                          ************      trkPtr + trkLen < bufEnd
                ;
                ; 1791 Sector Lengths:
                ;
                ; 00: 128	1 x 128
                ; 01: 256	2 x 128
                ; 02: 512	4 x 128
                ; 03: 1024	8 x 128
                ;
                ;*****************************************************************************
                
                ; DISK JOCKEY 2D Prom Address
                
 E000 =         DJBASE	equ	0E000h
 E3F8 =         IOBASE	equ	DJBASE+03f8H
                
                ; Disk information equates
                
 004D =         NUMTRK	equ	77		;number of tracks
 0000 =         MINDRV	equ	0		;first drive number
 0003 =         MAXDRV	equ	3		;max drive number 
                
 2000 =         LTRKLEN	equ	(8 * 1024)	;length of largest track in bytes
 0003 =         RDTRIES	equ	3		;disk retries per retry step
                
                ; Monitor, CP/M boot entry points
                
                MONITOR	set	init		;no monitor, just start over
                CPMBOOT	set	0		;CP/M warm boot jump vector
                
                ; XMODEM equates
                
 0080 =         PKTLEN	equ	128		;128 byte xmodem packet length
 0001 =         SOH	equ	001h
 0004 =         EOT	equ	004h
 0006 =         ACK	equ	006h
 0015 =         NAK	equ	015h
 001A =         EOF	equ	01ah		;ctrl-z character
 000A =         XMTRIES	equ	10		;number of xmodem retries
                
                ; CP/M Equates
                
 0000 =         WBOOT	equ	0		;warm boot jump vector
                
                ; Misc equates
                
 000D =         CR	equ	13		;ascii for carriage return
 000A =         LF	equ	10		;ascii for line feed
 007F =         DEL	equ	7fh		;ascii DEL
 0008 =         BS	equ	08h		;ascii backspace
 0003 =         CTRLC	equ	03		;ascii for control-c
 00C3 =         JMPINST	equ	0c3h		;jump instruction opcode
                
 0100           	org	0100h		;load address
                ;-----------------------------------------------------------------------------
                ;   Initialize for transfer
                ;-----------------------------------------------------------------------------
 0100 31EA08    init	lxi	sp,ourStk	;initialize stack pointer
 0103 CD0004    	call	chkCpm		;set flag for CP/M or not
 0106 CD3E04    	call	sizeRam		;determine amount of RAM available
 0109 CD8707    	call	s2Init		;initialize the 88-2SIO ports
 010C 3E00      	mvi	a,MINDRV	;a=default drive
 010E 329208    	sta	drvNum		;need for pgmExit
                
                ;  Display welcome message, then get the drive number and port number
                ;    to use for the transfer from the operator.
                
 0111 216F04    	lxi	h,mWelcom	;display welcome message
 0114 CD2B03    	call	dispMsg
                
                ; getDrv - get drive number or letter from the user.
                
 0117 213305    getDrv	lxi	h,mDrive	;display drive number prompt
 011A CD2B03    	call	dispMsg
 011D CD3603    	call	rcvCon		;get byte from the console
 0120 F620      	ori	20h		;upper case letters to lower case
 0122 FE78      	cpi	'x'		;exit requested?
 0124 CACE03    	jz	pgmExit		;yes
                
 0127 21A908    	lxi	h,baseDrv	;ascii 1st drive - baseDrv = 0
 012A 96        	sub	m
 012B FE04      	cpi	MAXDRV-MINDRV+1	;validate >=min drive and <= max drive
 012D D21701    	jnc	getDrv		;invalid, prompt again
                
 0130 C600      	adi	MINDRV		;restore offset of 1st drive (if any)
 0132 329208    	sta	drvNum		;save the drive number to use
 0135 CD2808    	call	dRestor		;restore to track 0 (selects drive)
 0138 D24401    	jnc	getPort
                
 013B 21DF06    	lxi	h,mIdErr	;could not read sector information
 013E CD2B03    	call	dispMsg
 0141 C31701    	jmp	getDrv
                
                ; getPort - get serial port number from the user.
                
 0144 216B05    getPort	lxi	h,mPort		;display transfer port prompt
 0147 CD2B03    	call	dispMsg
 014A CD3603    	call	rcvCon		;get byte from the console
 014D F620      	ori	20h		;upper to lower case, nums not affected
 014F FE78      	cpi	'x'		;exit requested?
 0151 CACE03    	jz	pgmExit		;yes
                
 0154 D631      	sui	'1'		;'1' - '3' to bianry 0-2
 0156 FE03      	cpi	3		;validate ascii 1-3
 0158 D24401    	jnc	getPort		;invalid, prompt again
                
 015B 32A008    	sta	xfrPort		;save the port to use
                
                ; Prompt the user to start the XMODEM receive operation on the PC. 
                ;    Wait for a clear receive line for a least one second, then start
                ;    looking for NAK or 'C' (crc protocol) from the PC
                
 015E 210306    	lxi	h,mStart	;display start file transfer prompt
 0161 CD2B03    	call	dispMsg
                
 0164 0602      clrRcv1	mvi	b,2		;2 second timeout
 0166 CD6D03    	call	rcvByte		;loop until input clear for 1 second
 0169 C26401    	jnz	clrRcv1
                
 016C AF        	xra	a		;set CRC flag to false (checksum mode)
 016D 32A308    	sta	crcFlag
                
 0170 CDBF03    waitNak	call	chkQuit		;give user chance to abort
 0173 0602      	mvi	b,2		;2 second
 0175 CD6D03    	call	rcvByte		;wait for a character
 0178 FE15      	cpi	NAK
 017A CA8501    	jz	haveNak		;have a NAK, use checksum protocol
                
 017D FE43      	cpi	'C'		;CRC protocol requested?
 017F C27001    	jnz	waitNak		;no
                
 0182 32A308    	sta	crcFlag		;set crc flag non-zero = CRC mode
                
                ;  NAK or 'C' received meaning the XMODEM receive has started. Initialize
                ;     for the transfer.
                
 0185 AF        haveNak	xra	a		;init track we want to zero
 0186 329308    	sta	trkNum
 0189 3C        	inr	a		;init xmodem block number to one
 018A 32A208    	sta	blkNum
                
                ;-----------------------------------------------------------------------------
                ;  mainLp - Loop through all tracks on the disk buffering as many tracks
                ;    as will fit in RAM before sending via xmodem, then repeat.
                ;-----------------------------------------------------------------------------
 018D 216A09    mainLp	lxi	h,trkBuf	;disk buffering always start at trkBuf
 0190 229908    	shld	trkPtr
                
                ; Read and buffer bufTrks tracks unless all tracks on drive reached first
                
 0193 CDD201    bufLoop	call	readTrk		;read into trkBuf
                
 0196 3A9308    	lda	trkNum		;increment track number (preserve HL)
 0199 3C        	inr	a
 019A 329308    	sta	trkNum	
 019D FE4D      	cpi	NUMTRK		;done all tracks on the disk?
 019F CAB801    	jz	sendBuf		;yes, go send the buffered tracks
                
 01A2 3A9F08    	lda	trkErr		;read failure on the track?
 01A5 B7        	ora	a		;if so, send buffered tracks now
 01A6 C2B801    	jnz	sendBuf		;so XMODEM won't time out
                
 01A9 EB        	xchg			;de=current track pointer
 01AA 2A9708    	lhld	trkLen		;fit another whole track?
 01AD 19        	dad	d
 01AE EB        	xchg			;de=end of next track pointer
 01AF 2A9B08    	lhld	bufEnd		;hl=end of buffering space
 01B2 CD6304    	call	cmpDeHl		;compare current-end
 01B5 DA9301    	jc	bufLoop		;still room, keep going	
                
                ; Track buffer is full or all tracks have been read. Send the buffered
                ;    tracks via xmodem.
                
 01B8 CD1F02    sendBuf	call	sndTrks		;send the buffered tracks via xmodem
 01BB 3A9308    	lda	trkNum
 01BE FE4D      	cpi	NUMTRK		;done all tracks?
 01C0 C28D01    	jnz	mainLp		;no, not done yet
                
                ; Send EOT and wait for response. Then display the success message and
                ;    start the program over.
                
 01C3 CDF302    noExtra	call	sndEot		;send and get response for EOT
                
 01C6 CD2808    	call	dRestor		;home
                
 01C9 213606    	lxi	h,mDone		;print the all done message
 01CC CD2B03    	call	dispMsg
                
 01CF C31701    	jmp	getDrv		;start over asking for a drive
                	
                ;-----------------------------------------------------------------------------
                ; readTrk - read numSecs sectors from the current track into a trkBuf as
                ;   pointed to by trkPtr. After the track is read, trkPtr is updated
                ;   by the length of a track to point to the next track buffer. This
                ;   saved value is also returned in HL.
                ;-----------------------------------------------------------------------------
 01D2 219308    readTrk	lxi	h,trkNum	;get desired track from trkNum	
 01D5 6E        	mov	l,m		;and put into l
 01D6 CD1208    	call	dSeek		;seek to the track
                
 01D9 AF        	xra	a
 01DA 329F08    	sta	trkErr		;no error on this track yet
                
                ; Read an entire track. Tracks are read every other sector because the
                ;   code in the DJ PROM can't keep up with consecutive sectors. Odd
                ;   sectors are read first followed by even sectors (e.g., sector 25 to 2
                ;   provides more time than 26 to 1). 
                
 01DD 1EFF      	mvi	e,0FFh		;e=sector number, start at -1
                
 01DF CDBF03    secLoop	call	chkQuit		;check for ctrl-c from operator
 01E2 CD4808    	call	dNxtSec		;e = next sector to read
 01E5 CD1803    	call	secOff		;hl->sector in trkBuf
 01E8 CD0308    	call	dRead		;read sector e into trkBuf
 01EB C20102    	jnz	secRtry		;error, run retry logic
                
 01EE 3A9608    nxtSec	lda	numSecs		;loop for all sectors
 01F1 BB        	cmp	e
 01F2 C2DF01    	jnz	secLoop
                
                ; track is done, set up for next track
                
 01F5 2A9708    	lhld	trkLen
 01F8 EB        	xchg			;de=track length
 01F9 2A9908    	lhld	trkPtr		;hl=current track pointer
 01FC 19        	dad	d		;hl=start of next track in trkBuf
 01FD 229908    	shld	trkPtr		;trkPtr = end of track + 1
 0200 C9        	ret
                
                ;--------------------------------------------------------------------------
                ; secRtry - Read error retry logic. Because of the limitations of the
                ;    DJ PROM, no head movment is done, just more reads.
                ;--------------------------------------------------------------------------	
 0201 3E03      secRtry	mvi	a,RDTRIES	;init retry counter
 0203 329D08    	sta	rdRtry
                
 0206 CDBF03    retryLp	call	chkQuit		;check for ctrl-c	
 0209 CD1803    	call	secOff		;hl->sector buffer
 020C CD0308    	call	dRead		;read the sector
 020F CAEE01    	jz	nxtSec		;success, retry is done
                
 0212 219D08    	lxi	h,rdRtry	;decrement retry counter
 0215 35        	dcr	m
 0216 C20602    	jnz	retryLp		;try again
                	
 0219 CD8203    	call	dspErr		;give up, display the error
 021C C3EE01    	jmp	nxtSec
                
                ;-----------------------------------------------------------------------------
                ; sndTrks - send the tracks buffered in trkBuf via xmodem. trkPtr points
                ;    to the end+1 of the data to send
                ;-----------------------------------------------------------------------------
 021F 2A9908    sndTrks	lhld	trkPtr		;hl=end of buffered data + 1
 0222 EB        	xchg			;de=end of buffered data + 1
 0223 216A09    	lxi	h,trkBuf	;trkBuf is initial starting point for
                
 0226 D5        sndLoop	push	d		;save end pointer
 0227 CD4102    	call	sndPkt		;send a packet
 022A D1        	pop	d		;de=end pointer
                
                ; At this point, hl->start of next packet and de->last byte read from disk+1.
                ;    If the next XMODEM packet will go past the end of the disk data,
                ;    we don't want to send it yet.
                
 022B 018000    	lxi	b,PKTLEN	;bc=length of XMODEM packet
 022E 09        	dad	b		;hl=address at end of NEXT packet + 1
 022F CD6304    	call	cmpDeHl		;compare disk end - end of next packet
 0232 D8        	rc			;done with track buffer, return
                
 0233 0180FF    	lxi	b,-PKTLEN	;restore hl
 0236 09        	dad	b
 0237 C32602    	jmp	sndLoop
                
                ; sndDone - reset sndPtr to start of track buffer
                
 023A 2A6A09    sndDone	lhld	trkBuf		;hl=trkBuf
 023D 22A608    	shld	sndPtr		;save address from which to send next time
                
 0240 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; sndPkt - send an xmodem format 128 byte packet. HL points to the 128 byte
                ;    buffer to send. On exit, HL points to the next 128 byte boundary.
                ;-----------------------------------------------------------------------------
 0241 3E0A      sndPkt	mvi	a,XMTRIES	;init retry counter
 0243 32A108    	sta	xmRetry
                
                ; First, send header bytes
                
 0246 CDBF03    reSend	call	chkQuit		;check for ctrl-c
 0249 E5        	push	h		;save hl for possible re-send
 024A 3E01      	mvi	a,SOH		;1st byte is SOH
 024C CD6403    	call	sndByte
 024F 3AA208    	lda	blkNum		;2nd byte is the block number
 0252 CD6403    	call	sndByte
 0255 2F        	cma			;2nd complement of block number
 0256 CD6403    	call	sndByte
                
                ; Init checksum and CRC and packet length for transmission of data portion
                
 0259 AF        	xra	a		;init crc
 025A 32A408    	sta	crc16
 025D 32A508    	sta	crc16+1
 0260 110080    	lxi	d,PKTLEN*256	;d=byte counter, e=0 (checksum)
                
                ; Loop sending the data bytes and updating checksum and CRC
                
 0263 7E        pktLoop	mov	a,m
 0264 CD6403    	call	sndByte		;send and update checksum in e
 0267 CDD302    	call	calCrc		;update the CRC
 026A 23        	inx	h		;point to next byte
 026B 15        	dcr	d		;decrement bytes remaining
 026C C26302    	jnz	pktLoop
                
                ; Send checksum or CRC based on crcFlag
                
 026F 3AA308    	lda	crcFlag		;crc or checksum?
 0272 B7        	ora	a
 0273 CA8202    	jz	sndCsum		;flag clear = checksum
                
 0276 3AA508    	lda	crc16+1		;a=high byte of CRC
 0279 CD6403    	call	sndByte		;send it
 027C 3AA408    	lda	crc16		;a=low byte of crc
 027F C38302    	jmp	sndSkip		;skip next instruction	
                
 0282 7B        sndCsum	mov	a,e		;send the checksum byte
                
 0283 CD6403    sndSkip	call	sndByte
                
                ;  All bytes sent. Wait for the response.
                
 0286 0605      	mvi	b,5		;5 second timeout
 0288 CD6D03    	call	rcvByte		;get the response character
 028B CA9C02    	jz	sndFail		;timeout on response
                
 028E FE06      	cpi	ACK		;ack received?
 0290 C29C02    	jnz	sndFail		;no, send failed
                
 0293 3AA208    	lda	blkNum		;increment block number
 0296 3C        	inr	a
 0297 32A208    	sta	blkNum
                
 029A C1        	pop	b		;remove pushed hl, but don't clobber hl
 029B C9        	ret
                
                ; sndFail - ACK not received, decrement retry and try again.
                
 029C 21A108    sndFail	lxi	h,xmRetry	;point to retry counter
 029F 35        	dcr	m
 02A0 CAC702    	jz	xmFail		;retries used up, failed xmodem transfer
                
                ; If we've had 3 NAKs on the 1st packet and CRC is selected, assume
                ;   we took so long to send the 1st packet due to disk retries that
                ;   the receiver has since timed out and switched to checksum
                
 02A3 3AA308    	lda	crcFlag		;are we in CRC mode
 02A6 CABB02    	jz	clrRcv2		;no, ignore the rest of this
                
 02A9 3AA208    	lda	blkNum		;on block 1?
 02AC 3D        	dcr	a
 02AD C2BB02    	jnz	clrRcv2		;no, go on
                
 02B0 3AA108    	lda	xmRetry		;failed three times in a row on block 1?
 02B3 D607      	sui	XMTRIES-3
 02B5 C2BB02    	jnz	clrRcv2		;no
                
 02B8 32A308    	sta	crcFlag		;clear crcFlag to force checksum
                
                ;  clrRcv2 - wait for one second of line clear time and send packet again.
                
 02BB 0602      clrRcv2	mvi	b,2		;2 second timeout
 02BD CD6D03    	call	rcvByte		;wait for 1 second of clear line
 02C0 C2BB02    	jnz	clrRcv2
                
 02C3 E1        	pop	h		;restore pointer to the packet
 02C4 C34602    	jmp	reSend		;re-send the packet
                
                ;  xmFail - Display failure message then restart program
                
 02C7 216B06    xmFail	lxi	h,mXmdm		;xmodem failure message
 02CA CD2B03    	call	dispMsg
                
 02CD 31EA08    	lxi	sp,ourStk	;initialize stack pointer
 02D0 C31701    	jmp	getDrv		;start over asking for drive
                
                ;-----------------------------------------------------------------------------
                ; calCrc - update the 16-bit CRC with one more byte. 
                ;    (Copied from M. Eberhard)
                ; On Entry:
                ;   a has the new byte
                ;   crc16 is current except this byte
                ; On Exit:
                ;   crc16 has been updated
                ;   Trashes a,bc
                ;-----------------------------------------------------------------------------
 02D3 D5        calCrc	push	d
 02D4 E5        	push	h
 02D5 2AA408    	lhld	crc16		;get CRC so far
 02D8 AC        	xra	h		;XOR into CRC top byte
 02D9 67        	mov	h,a
 02DA 012110    	lxi	b,1021h		;bc=CRC16 polynomial
 02DD 1608      	mvi	d,8		;prepare to rotate 8 bits
                
                ; do 8 bit shift/divide by CRC polynomial
                
 02DF 29        cRotLp	dad	h		;16-bit shift
 02E0 D2E902    	jnc	cClr		;skip if bit 15 was 0
 02E3 7C        	mov	a,h		;CRC=CRC xor 1021H
 02E4 A8        	xra	b
 02E5 67        	mov	h,a
 02E6 7D        	mov	a,l
 02E7 A9        	xra	c
 02E8 6F        	mov	l,a
 02E9 15        cClr	dcr	d
 02EA C2DF02    	jnz	cRotLp		;rotate 8 times
                
                ; save the updated CRC and exit
                
 02ED 22A408    	shld	crc16		;save updated CRC
 02F0 E1        	pop	h
 02F1 D1        	pop	d
 02F2 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ;  sndEot - send EOT character and wait for ACK response
                ;-----------------------------------------------------------------------------
 02F3 3E0A      sndEot	mvi	a,XMTRIES	;init retry counter
 02F5 32A108    	sta	xmRetry
                
 02F8 3E04      reEot	mvi	a,EOT
 02FA CD6403    	call	sndByte
 02FD 0605      	mvi	b,5		;5 second timeout
 02FF CD6D03    	call	rcvByte		;
 0302 CA0B03    	jz	eotFail		;timeout
                
 0305 FE06      	cpi	ACK		;ack received?
 0307 C20B03    	jnz	eotFail		;no, eot send failed
                
 030A C9        	ret			;otherwise, we're done.
                
                ; timeout waiting for ACK to EOT. Decrement retry counter and try again
                
 030B 21A108    eotFail	lxi	h,xmRetry	;point to retry counter
 030E 35        	dcr	m
 030F C2F802    	jnz	reEot
                
                ;just give up - xfer was probably good
                
 0312 214E06    	lxi	h,mNoAck
 0315 C32B03    	jmp	dispMsg
                
                ;--------------------------------------------------------------
                ; secOff - calculate sector buffer within trkPtr
                ; On Entry:
                ;    trkPtr = start of current track buffer
                ;    secLen = length of sectors in this track
                ;    e = sector number
                ; On Exit:
                ;    hl = sector buffer within trkPtr
                ;    e = sector number
                ; Cobbers:
                ;    a
                ;--------------------------------------------------------------
 0318 7B        secOff  mov	a,e		;a = sector number
 0319 2A9408    	lhld	secLen		;get sector length
 031C 44        	mov	b,h		;bc = sector length
 031D 4D        	mov	c,l
 031E 2A9908    	lhld	trkPtr		;hl = start of current track buffer
 0321 3D        	dcr	a		;sector 1?
 0322 CA2A03    	jz	secOffD		;yes
                
 0325 09        secOffL	dad	b		;add sector offset to hl
 0326 3D        	dcr	a		;decrement sector
 0327 C22503    	jnz	secOffL		;loop until done
                
 032A C9        secOffD	ret			;return hl=sector buffer
                	
                ;-----------------------------------------------------------------------------
                ; dispMsg - display the null-terminated message passed in hl on the
                ;    console device. Clobbers b, hl
                ;-----------------------------------------------------------------------------
 032B 7E        dispMsg	mov	a,m		;get the next message byte
 032C 23        	inx	h		;move to next byte
 032D B7        	ora	a		;null terminates
 032E C8        	rz
                
 032F 47        	mov	b,a		;conOut wants character in b
 0330 CDA407    	call	conOut
 0333 C32B03    	jmp	dispMsg
                
                ;-----------------------------------------------------------------------------
                ; rcvCon - Receive a character from the console device, echo it, then
                ;   wait for a CR. Exits program if Ctrl-c typed. Returns with invalid
                ;   character (null) if BS or DEL pressed after 1st character
                ;   Returns character in a, clobbers b.
                ;-----------------------------------------------------------------------------
 0336 CD9807    rcvCon	call	conIn		;check for input
 0339 CA3603    	jz	rcvCon		;nothing
                
 033C E67F      	ani	7fh
 033E FE03      	cpi	CTRLC		;abort requested?
 0340 CACE03    	jz	pgmExit		;yes
                
 0343 FE0D      	cpi	CR		;return pressed?
 0345 C8        	rz			;yes, don't echo it
                
 0346 47        	mov	b,a		;conOut needs character in b
 0347 CDA407    	call	conOut		;echo it
                
                ; Wait for CR, then return 1st character typed
                
 034A CD9807    rcvCr	call	conIn		;check for input
 034D CA4A03    	jz	rcvCr		;nothing
                
 0350 E67F      	ani	7Fh
 0352 FE03      	cpi	CTRLC		;abort requested?
 0354 CACE03    	jz	pgmExit		;yes
                
 0357 FE7F      	cpi	DEL		;delete
 0359 C8        	rz			;yes, return DEL character
                
 035A FE08      	cpi	BS		;backspace?
 035C C8        	rz			;yes, return BS character
                
 035D FE0D      	cpi	CR		;return pressed?
 035F C24A03    	jnz	rcvCr		;no, keep waiting
                
 0362 78        	mov	a,b		;return 1st character typed
 0363 C9        	ret
                
                ;-----------------------------------------------------------------------------
                ; sndByte - send the byte in a through the specified transfer port. 
                ;     Adds the byte to register e for checksum. Clobbers b.
                ;     XMODEM send routine assumes serOut returns with a containing
                ;     the character sent.
                ;-----------------------------------------------------------------------------
 0364 47        sndByte	mov	b,a		;b=byte to transmit
 0365 83        	add	e		;update checksum
 0366 5F        	mov	e,a		;e=updated checksum
 0367 3AA008    	lda	xfrPort		;a=port to use for transfer
 036A C3D607    	jmp	serOut		;send the character
                
                ;-----------------------------------------------------------------------------
                ; rcvByte - Receive a byte from specified transfer port with a 'b' second
                ;     timeout. If a timeout occurs, zero is returned in A and the zero 
                ;     flag is true. Otherwise, the character is returned in A (could be
                ;     zero) and zero flag is false. ONESEC must be set based on processor
                ;     speed and the number of cycles in the serIn call + 59. 
                ;     Clobbers a, b, d, and e.
                ;-----------------------------------------------------------------------------
 036D 111F4B    rcvByte lxi     d,ONESEC        ;de=cycles through this loop for 1s
                
 0370 3AA008    rcvWait lda     xfrPort         ;(13) a=port to use for transfer
 0373 CDB307            call    serIn           ;(17+cycles in serIn)look for a byte
 0376 C0                rnz                     ;(5)byte received
                
 0377 1B                dcx     d               ;(5)otherwise, decrement timer
 0378 7A                mov     a,d             ;(5)one second expire?
 0379 B3                ora     e               ;(4)
 037A C27003            jnz     rcvWait         ;(10)no, keep waiting
 037D 05                dcr     b               ;seconds left?
 037E C27003            jnz     rcvWait
                
 0381 C9        	ret			;return with timeout (zero true and in a)
                
                ;-----------------------------------------------------------------------------
                ; dspErr - display the current track and sector number which just had
                ;     a read error. If this is the first error on a track, the track
                ;     number is displayed first.
                ;
                ;  on entry:
                ;     e = sector number
                ;-----------------------------------------------------------------------------
 0382 3A9F08    dspErr	lda	trkErr		;test track error flag
 0385 B7        	ora	a
 0386 C29C03    	jnz	dspSec		;track already displayed, go display sector
                
 0389 3C        	inr	a		;set track flag non-zero
 038A 329F08    	sta	trkErr
                
                ; First error on this track. Display "Track xx errors: "
                
 038D 212507    	lxi	h,errTrk	;hl->where to put ascii decimal
 0390 3A9308    	lda	trkNum		;a=track with error on it
 0393 CDA703    	call	bin2dec		;track to ascii
 0396 211D07    	lxi	h,mTrkErr	;display the track error message
 0399 CD2B03    	call	dispMsg
                
                ; dspSec - display the sector number with an error
                
 039C 213907    dspSec	lxi	h,errSec	;hl->where to put ascii sector
 039F 7B        	mov	a,e		;a=sector where error occured
 03A0 CDA703    	call	bin2dec
 03A3 CD2B03    	call	dispMsg		;display the error
 03A6 C9        	ret
                
                ;--------------------------------------------------------------
                ; bin2dec - Binary byte in A to 2 ASCII digits at (HL)
                ;   HL is preserved
                ;--------------------------------------------------------------
 03A7 3620      bin2dec	mvi	m,' '		;assume zero supression
 03A9 D60A      	sui	10		;value less than 10?
 03AB DAB903    	jc	do1s		;yes, leading blank
 03AE 3631      	mvi	m,'1'		;have one ten already
                
 03B0 D60A      loop10	sui	10		;count 10s
 03B2 DAB903    	jc	do1s		;done with 10s, do 1s
 03B5 34        	inr	m
 03B6 C3B003    	jmp	loop10
                
 03B9 C63A      do1s	adi	'0'+10		;form ASCII 1s digit
 03BB 23        	inx	h		;move to 1s position
 03BC 77        	mov	m,a
 03BD 2B        	dcx	h		;restore hl
 03BE C9        	ret
                
                ;--------------------------------------------------------------
                ; chkQuit - check for the user to request abort (ctrl-c). If
                ;    a character is present on the console port, read it and
                ;    see if ctrl-c. Clobbers A
                ;--------------------------------------------------------------
 03BF CD9807    chkQuit	call	conIn		;check for console input
 03C2 C8        	rz
                
 03C3 E67F      	ani	7fh
 03C5 FE03      	cpi	CTRLC		;abort requested?
 03C7 C0        	rnz			;no
                
                ; Ctrl-C typed while program is running. Return to drive prompt.
                
 03C8 31EA08    	lxi	sp,ourStk	;initialize stack pointer
 03CB C31701    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; pgmExit - Exit to CP/M or to the monitor ROM based on the
                ;    CP/M flag
                ;--------------------------------------------------------------
 03CE 3AA808    pgmExit	lda	cpmFlag		;running under CP/M?
 03D1 B7        	ora	a
 03D2 C2DE03    	jnz	cpmExit		;yes
                
                ; Exit to ROM monitor
                
 03D5 213D07    	lxi	h,mExit		;display "exiting" message
 03D8 CD2B03    	call	dispMsg
 03DB C30001    	jmp	MONITOR		;jump to ROM monitor entry point
                
                ; CP/M exit. If boot drive was used, prompt user to insert CP/M disk
                
 03DE 3A9208    cpmExit	lda	drvNum		;boot drive used?
 03E1 D600      	sui	MINDRV
 03E3 C2EF03    	jnz	noDisk		;not 1, disk prompt not needed
                
 03E6 214D07    	lxi	h,mCpm		;display "insert cp/m disk"	
 03E9 CD2B03    	call	dispMsg
 03EC CD3603    	call	rcvCon		;wait for a character
                
 03EF 3E00      noDisk	mvi	a,MINDRV	;re-select drive A for CP/M 1.4
 03F1 329208    	sta	drvNum
 03F4 CD4008    	call	dSelDrv
                
 03F7 213D07    	lxi	h,mExit		;display "exiting" message
 03FA CD2B03    	call	dispMsg
 03FD C30000    	jmp	CPMBOOT		;reboot CP/M
                
                ;--------------------------------------------------------------
                ; chkCpm - check if running under CP/M. CP/M flag is set true
                ;   (non-zero) if yes, cleared otherwise.
                ;--------------------------------------------------------------
                ; First, initialize entries for stand-alone
                
 0400 AF        chkCpm	xra	a
 0401 32A808    	sta	cpmFlag		;clear CP/M flag
 0404 3E30      	mvi	a,MINDRV+'0'	;ascii for minimum drive number
 0406 325705    	sta	mDrvMin		;store in the drive prompt message
 0409 32A908    	sta	baseDrv		;ascii 1st drive - baseDrv = 0
 040C 3E33      	mvi	a,MAXDRV+'0'	;ascii for max drive number
 040E 325905    	sta	mDrvMax
                
                ; Determine if we're under CP/M or standalone. CP/M is assumed if
                ;   a jump instruction is present at the CP/M warm start location (0)
                ;   and five more jumps (e.g., a jump table) is present at the
                ;   jump-to destination.
                		
 0411 3A0000    	lda	WBOOT		;see if jump instruction present for CP/M
 0414 FEC3      	cpi	JMPINST
 0416 C0        	rnz			;no, not CP/M
                
                ; A jump instruction is present at the CP/M warm boot location (0),
                ;   now see if that jump points to five more jumps. If so, assume CP/M
                
 0417 210100    	lxi	h,WBOOT+1	;point to lsb of jump address
 041A 5E        	mov	e,m		;e=low byte of jump
 041B 23        	inx	h
 041C 56        	mov	d,m		;de=destination of jump
 041D 0605      	mvi	b,5		;look for 5 more jumps (a jump table)
                
 041F 1A        jmpTest	ldax	d		;a=opcode at jump destination
 0420 D6C3      	sui	JMPINST		;another jump present?
 0422 C0        	rnz			;no, not CP/M
 0423 13        	inx	d		;move to next jump
 0424 13        	inx	d
 0425 13        	inx	d
 0426 05        	dcr	b
 0427 C21F04    	jnz	jmpTest
                
 042A 3D        	dcr	a		;a=0ffh
 042B 32A808    	sta	cpmFlag		;CP/M flag to non-zero = true
                
                ; We're running under CP/M. Change drive prompt message to show drive
                ;    letters instead of drive numbers and change baseDrv to convert
                ;    an 'A' to the base drive number (MINDRV).
                
 042E 3E41      	mvi	a,'A'		;'A' in drive message instead of number
 0430 325705    	sta	mDrvMin
 0433 C603      	adi	MAXDRV-MINDRV	;max drive letter
 0435 325905    	sta	mDrvMax
 0438 3E61      	mvi	a,'a'		;ascii 1st drive - baseDrv = 0
 043A 32A908    	sta	baseDrv
 043D C9        	ret
                
                ;------------------------------------------------------------------
                ; sizeRam - determine how much RAM we have for buffering tracks.
                ;   Sets the bufEnd variable which points to end address of 
                ;   the last possible track buffer + 1
                ;------------------------------------------------------------------
                ; If running under CP/M, use the BIOS pointer to determine the top
                ;    of available RAM. Otherwise, size RAM manually.
                
 043E 2A0100    sizeRam	lhld	WBOOT+1		;get address of BIOS jump table+3
 0441 2B        	dcx	h		
 0442 2B        	dcx	h
 0443 2B        	dcx	h		;hl->top of usable ram+1
 0444 3AA808    	lda	cpmFlag		;running under CP/M?
 0447 B7        	ora	a
 0448 C25904    	jnz	ramEnd		;yes, we have the end of RAM
                
                ;  Not under CP/M. Find the end of RAM manually.
                
 044B 21000A    	lxi	h,(trkBuf+0ffh) AND 0ff00h   ;next 256 byte boundary
                
 044E 7E        ramLoop	mov	a,m		;a=current RAM content
 044F 34        	inr	m		;change RAM
 0450 BE        	cmp	m		;did RAM change?
 0451 77        	mov	m,a		;restore RAM
 0452 CA5904    	jz	ramEnd		;end of RAM found
                
 0455 24        	inr	h		;next page
 0456 C24E04    	jnz	ramLoop
                
                ; ramEnd - end of RAM found. Subtract 256 bytes because it seems
                ;   like a good idea.
                
 0459 25        ramEnd	dcr	h		;back 1 page
 045A 229B08    	shld	bufEnd		;save as bufEnd
 045D C9        	ret
                
                ;--------------------------------------------------------------------
                ; cmHlDe - compare HL-DE. Carry set if HL<DE, carry clear if HL>=DE
                ;--------------------------------------------------------------------
 045E 7D        cmpHlDe	mov	a,l		;compare HL-DE, do lsbs first
 045F 93        	sub	e
 0460 7C        	mov	a,h		;do msbs
 0461 9A        	sbb	d
 0462 C9        	ret			;carry set HL<DE, clear HL>=DE
                
                ;--------------------------------------------------------------------
                ; cmDeHl - compare DE-HL. Carry set if DE<HL, carry clear if DE>=HL
                ;--------------------------------------------------------------------
 0463 7B        cmpDeHl	mov	a,e		;compare DE-HL, do lsbs first
 0464 95        	sub	l
 0465 7A        	mov	a,d		;do msbs
 0466 9C        	sbb	h
 0467 C9        	ret			;carry set DE<HL, clear DE>=HL
                
                ;--------------------------------------------------------------------
                ; subDeHl - HL=DE-HL
                ;--------------------------------------------------------------------
 0468 7B        subDeHl	mov	a,e		;subtract DE-HL, do lsbs first
 0469 95        	sub	l
 046A 6F        	mov	l,a		;lsb result in l
 046B 7A        	mov	a,d		;do msbs
 046C 9C        	sbb	h
 046D 67        	mov	h,a		;msb result in h	
 046E C9        	ret
                
                ;---------------------------------------------------------------------
                ; Message constants
                ;---------------------------------------------------------------------
 046F 0D0A0A    mWelcom	db	cr,lf,lf
 0472 3D3D3D3D3D	db	'===== Floppy to PC Disk Image Transfer =====',cr,lf
 04A0 2020202020	db	'      (DJ2D Controller @ E000, ver 1.1)',cr,lf,lf
 04CA 53656E6473	db	'Sends an image of an 8" floppy to a PC via the DJ2D'
 04FD 0D0A      	db	cr,lf
 04FF 6F72203838	db	'or 88-2SIO serial port using the XMODEM protocol.',cr,lf,0
                
 0533 0D0A0A496EmDrive	db	cr,lf,lf,'Insert and specify source drive ('
 0557 782D      mDrvMin	db	'x-'
 0559 7829206F72mDrvMax	db	'x) or X to exit: ',0
                
 056B 0D0A0A    mPort	db	cr,lf,lf
 056E 5370656369	db	'Specify the port to use for file transfer',cr,lf
 0599 2020312920	db	'  1) DJ2D (which is also the console)',cr,lf
 05C0 2020322920	db	'  2) 88-2SIO port A',cr,lf
 05D5 2020332920	db	'  3) 88-2SIO port B',cr,lf
 05EA 456E746572	db	'Enter 1-3 or X to exit: ',0
                
 0603 0D0A0A5374mStart	db	cr,lf,lf,'Start XMODEM receive operation on the PC now...',0
                
 0636 0D0A0A5472mDone	db	cr,lf,lf,'Transfer complete!',cr,lf,0
                
 064E 0D0A0A4E6FmNoAck	db	cr,lf,lf,'No ACK received on EOT.',cr,lf,0
                
 066B 0D0A0A584DmXmdm	db	cr,lf,lf,'XMODEM communication failure',cr,lf,0
                
 068D 0D0A0A5365mNoTrk0	db	cr,lf,lf,'Seek to track 0 failed',cr,lf,0
                
 06A9 0D0A0A4472mNotRdy	db	cr,lf,lf,'Drive not ready. Insert formatted disk or Ctrl-C',cr,lf,0
                
 06DF 0D0A0A436FmIdErr	db	cr,lf,lf,'Could not read address from track 1.',cr,lf
 0708 4973206469	db	'Is disk formatted?',cr,lf,0
                
 071D 0D0A547261mTrkErr	db	cr,lf,'Track '
 0725 7878206661errTrk	db	'xx failed sectors: ',0
 0739 78782000  errSec	db	'xx ',0
                
 073D 0D0A0A4578mExit	db	cr,lf,lf,'Exiting...',cr,lf,0
                
 074D 0D0A0A    mCpm	db	cr,lf,lf
 0750 496E736572	db	'Insert CP/M disk into drive A, then press Return...',0
                
 0784 0D0A00    mCrLf	db	cr,lf,0
                
                
                ;****************************************************************************
                ;
                ;  Hardware specific console and serial I/O routines. 
                ;     The following four routines must be written to provide a common
                ;     interface to the hardware on which this program is running. The
                ;     port number specified for serIn and serOut matches the port number
                ;     input from the operator via the port menu.
                ;
                ;****************************************************************************
                
                ; DJ2D Serial Port Equates
                
 E3F8 =         djDat	equ	IOBASE+0
 E3F9 =         djCtl	equ	IOBASE+1
 0004 =         djDr	equ	004h		;data ready flag
 0008 =         djTbre	equ	008h		;transmit buffer register empty flag
                
                ; 88-2SIO Serial Board Equates
                
 0010 =         s2aCtl	equ	010h		;1st port on 88-2SIO board - control register
 0011 =         s2aDat	equ	011h		;1st port on 88-2SIO board - data register
 0012 =         s2bCtl	equ	012h		;2nd port on 88-2SIO board - control register
 0013 =         s2bDat	equ	013h		;2nd port on 88-2SIO board - data register
 0001 =         s2Rdrf	equ	001h		;read data register full flag
 0002 =         s2Tdre	equ	002h		;transmit data register empty flag
 0003 =         s2Rst	equ	003h		;reset command
 0015 =         s28n1	equ	015h		;8N1 selection
 0011 =         s28n2	equ	011h		;8N2 selection
                
                ; 88-SIO Serial board Equates
                
 0000 =         sioCtl	equ	00h		;control port
 0001 =         sioDat	equ	01h		;data port
 0001 =         sioRdrf	equ	00000001b	;-RX Data register full
 0080 =         sioTdre	equ	10000000b	;-TX Data register empty
                
                ; The rcvByte subroutine above times a one second timeout with a code
                ;    loop that calls the hardware specific serIn routine below. ONESEC
                ;    must be set based on processor speed and the number of cycles in 
                ;    the serIn call + 59 cycles for the rcvByte code. 
                
 4B1F =         ONESEC	equ	19231		;rcvByte loop count for 1 second
                
                ;----------------------------------------------------------------------------
                ; s2Init - reset and initialize 88-2SIO ports for 8N1
                ;----------------------------------------------------------------------------
 0787 3E03      s2Init	mvi	a,s2Rst		;reset and init 1st 88-2SIO port
 0789 D310      	out	s2aCtl
 078B 3E15      	mvi	a,s28n1		;transfer port as 8N1
 078D D310      	out	s2aCtl
                
 078F 3E03      	mvi	a,s2Rst		;reset and init 2nd 88-2SIO port
 0791 D312      	out	s2bCtl
 0793 3E15      	mvi	a,s28n1		;transfer port as 8N1
 0795 D312      	out	s2bCtl
 0797 C9        	ret	
                
                ;----------------------------------------------------------------------------
                ; conIn - input character from console
                ;    inputs:
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ;    clobbers none
                ;----------------------------------------------------------------------------
 0798 3AF9E3    conIn	lda	djCtl		;see if a new character is present
 079B 2F        	cma			;status is inverted
 079C E604      	ani	djDr
 079E C8        	rz			;no character, return zero status
                
 079F 3AF8E3    	lda	djDat		;return character and non-zero status
 07A2 2F        	cma			;byte is inverted
 07A3 C9        	ret	
                
                ;----------------------------------------------------------------------------
                ; conOut - output character to console
                ;    inputs: b = character to send
                ;    clobbers a
                ;----------------------------------------------------------------------------
 07A4 3AF9E3    conOut	lda	djCtl		;wait for OK to transmit
 07A7 2F        	cma			;status is inverted
 07A8 E608      	ani	djTbre
 07AA CAA407    	jz	conOut
 07AD 78        	mov	a,b		;a=character to transmit
 07AE 2F        	cma			;byte is inverted
 07AF 32F8E3    	sta	djDat		;send it
 07B2 C9        	ret
                
                ;----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serIn - input character from port specified in a
                ;       0 = DJ2D
                ;       1 = 88-2SIO port A
                ;       2 = 88-2SIO port B
                ;    inputs: a = port to read from
                ;    outputs: z true if no character present
                ;	      z false if character returned in a
                ;    clobbers none
                ; 88-2SIO Port A: 53 cycles including return when no character present
                ; 88-2SIO Port B: 43 cycles including return when no character present
                ;-----------------------------------------------------------------------------
 07B3 3D        serIn	dcr	a		;(5)3-way test
 07B4 CAC607    	jz	s2InA		;(10)a was 1: 88-2SIO port A
 07B7 F2CE07    	jp	s2InB		;(10)a was 2: 88-2SIO port B
                				;    a was 0: DJ2D
                ; Input from DJ2D
 07BA 3AF9E3    djIn	lda	djCtl		;see if a new character is present
 07BD 2F        	cma			;status is inverted
 07BE E604      	ani	djDr
 07C0 C8        	rz			;no character, return zero status
                
 07C1 3AF8E3    	lda	djDat		;return character and non-zero status
 07C4 2F        	cma			;byte is inverted
 07C5 C9        	ret	
                
                ; Input from 88-2SIO port A
                
 07C6 DB10      s2InA	in	s2aCtl		;(10+1)see if a new character is present
 07C8 E601      	ani	s2Rdrf		;(7)
 07CA C8        	rz			;(10)no character, return zero status
 07CB DB11      	in	s2aDat		;return character and non-zero status
 07CD C9        	ret	
                	
                ; Input from 88-2SIO port B
                
 07CE DB12      s2InB	in	s2bCtl		;(10+1)see if a new character is present
 07D0 E601      	ani	s2Rdrf		;(7)
 07D2 C8        	rz			;(10)no character, return zero status
                
 07D3 DB13      	in	s2bDat		;return character and non-zero status
 07D5 C9        	ret	
                
                ;-----------------------------------------------------------------------------
                ; Hardware specific I/O
                ; serOut - output character to port specified in a
                ;       0 = 88-2SIO port A
                ;       1 = 88-2SIO port B
                ;       2 = 88-SIO
                ;    inputs: a = port to transmit through
                ;	     b = character to send
                ;   outputs: a = character sent
                ;-----------------------------------------------------------------------------
 07D6 3D        serOut	dcr	a		;3-way test
 07D7 CAED07    	jz	s2OutA		;a was 1: 88-2SIO port A
 07DA F2F807    	jp	s2OutB		;a was 2: 88-2SIO port B
                				;a was 0: DJ2D
                ; Send character through DJ2D
                
 07DD 3AF9E3    djOut	lda	djCtl		;wait for OK to transmit
 07E0 2F        	cma			;status is inverted
 07E1 E608      	ani	djTbre
 07E3 CADD07    	jz	djOut
 07E6 78        	mov	a,b		;a=character to transmit
 07E7 2F        	cma			;byte is inverted
 07E8 32F8E3    	sta	djDat		;send it
 07EB 2F        	cma			;uninvert
 07EC C9        	ret
                
                ; Send character through 88-2SIO port A
                
 07ED DB10      S2OutA	in	s2aCtl		;wait for OK to transmit
 07EF E602      	ani	s2Tdre
 07F1 CAED07    	jz	S2OutA
                
 07F4 78        	mov	a,b		;a=character to transmit
 07F5 D311      	out	s2aDat		;send it
 07F7 C9        	ret
                
                ; Send character through 88-2SIO port B
                
 07F8 DB12      s2OutB	in	s2bCtl		;wait for OK to transmit
 07FA E602      	ani	s2Tdre
 07FC CAF807    	jz	s2OutB
                
 07FF 78        	mov	a,b		;a=character to transmit
 0800 D313      	out	s2bDat		;send it
 0802 C9        	ret
                
                ;****************************************************************************
                ;
                ; DJ2D disk I/O routines
                ;
                ;****************************************************************************
                
                ; DJ2D Disk Drive Controller Equates
                
 E000 =         DBOOT	equ	DJBASE		;DOS bootstrap routine
 E003 =         TERMIN	equ	DJBASE+003H	;serial input
 E006 =         TRMOUT	equ	DJBASE+006H	;serial output
 E009 =         TKZERO	equ	DJBASE+009H	;recalibrate (seek to TRK0)
 E00C =         TRKSET	equ	DJBASE+00CH	;seek
 E00F =         SETSEC	equ	DJBASE+00FH	;select sector
 E012 =         SETDMA	equ	DJBASE+012H	;set DMA address
 E015 =         READ	equ	DJBASE+015H	;read a sector of disk data
 E018 =         WRITE	equ	DJBASE+018H	;write a sector of disk data
 E01B =         SELDRV	equ	DJBASE+01BH	;select a disk drive
 E01E =         TPANIC	equ	DJBASE+01EH	;test for panic character
 E021 =         TSTAT	equ	DJBASE+021H	;serial status input
 E024 =         DMAST	equ	DJBASE+024H	;read current DMA address
 E027 =         STATUS	equ	DJBASE+027H	;disk status input
 E02A =         DSKERR	equ	DJBASE+02AH	;loop to strobe error LED
 E02D =         SETDEN	equ	DJBASE+02DH	;set density
 E030 =         SETSID	equ	DJBASE+030H	;set side for 2-headed drives
                
                ;--------------------------------------------------------------
                ; dRead - Read sector on current track.
                ; On Entry:
                ;    Drive is selected, on proper track
                ;    hl->sector buffer
                ;    e = sector number to read
                ; On Exit:
                ;    Z flag set = good, Z flag clear = error
                ;    clobbers b,c,h,l
                ;--------------------------------------------------------------
 0803 D5        dRead	push	d		;save de
 0804 4B        	mov	c,e		;sector number in c
 0805 CD0FE0    	call	SETSEC		;set sector
 0808 44        	mov	b,h		;bc = hl
 0809 4D        	mov	c,l
 080A CD12E0    	call	SETDMA
 080D CD15E0    	call	READ
 0810 D1        	pop	d		;restore de
 0811 C9        	ret
                
                ;--------------------------------------------------------------
                ; dSeek - Seek track specified in L.
                ; On Entry:
                ;    l = desired track
                ; On Exit:
                ;    
                ; Clobbers none
                ;--------------------------------------------------------------
 0812 CD4008    dSeek	call	dSelDrv		;make sure drive is selected
                
 0815 4D        	mov	c,l		;track to c
 0816 CD0CE0    	call	TRKSET		;set track
 0819 FE02      	cpi	2
 081B D0        	rnc			;return if track > 1
                
 081C 1E01      	mvi	e,1		;read sector 1
 081E 2A9908    	lhld	trkPtr		;hl=track pointer
 0821 CD0308    	call	dRead
 0824 CD5208    	call	dSecFmt		;get sector format
                
 0827 C9        	ret
                
                ;--------------------------------------------------------------
                ; dRestor - Selects drive, loads heads and restores to track 0.
                ;    If restore fails, message display and program restarted
                ;    at getDrv.
                ; On Entry:
                ;    drvNum = drive to be selected and restored to track zero
                ; On Exit:
                ;    drive selected and on track zero
                ; Clobbers none 
                ;--------------------------------------------------------------
 0828 CD4008    dRestor	call	dSelDrv		;make sure drive is selected
 082B CD09E0    	call	TKZERO
 082E CD27E0    	call	STATUS
 0831 79        	mov	a,c		;get track number
 0832 B7        	ora	a		;track 0?
 0833 C8        	rz			;yes, return
                
                ; restore failed
                
 0834 218D06    	lxi	h,mNoTrk0
                
 0837 CD2B03    errMsg	call	dispMsg
 083A 31EA08    	lxi	sp,ourStk	;initialize stack pointer
 083D C31701    	jmp	getDrv		;start over asking for drive num
                
                ;--------------------------------------------------------------
                ; dSelDrv - Select drive specified in drvNum 
                ; On Entry:
                ;    drvNum = drive to be selected
                ; On Exit:
                ;    drive selected
                ; Clobbers a,c
                ;--------------------------------------------------------------
 0840 3A9208    dSelDrv	lda	drvNum		;a=desired drive
 0843 4F        	mov	c,a
 0844 CD1BE0    	call	SELDRV
 0847 C9        	ret
                
                ;--------------------------------------------------------------
                ; dNextSec - Move to next sector. Reads odd sectors first
                ;    then even sectors. Very first call for a track should
                ;    have sector -1 in e.
                ; On Entry:
                ;    e = last sector read 
                ; On Exit:
                ;    e = new sector to read
                ; Clobbers e
                ;--------------------------------------------------------------
 0848 1C        dNxtSec	inr	e		;read every other sector
 0849 1C        	inr	e
 084A 3A9608    	lda	numSecs		;past end?
 084D BB        	cmp	e
 084E D0        	rnc			;no
                
 084F 1E02      	mvi	e,2		;else, do even sectors
 0851 C9        	ret
                
                ;--------------------------------------------------------------
                ; dSecFmt - Set sectors per track, sector length, and track
                ;    length from the most recent sector read.
                ; On Entry:
                ;    drive selected
                ; On Exit:
                ;    numSecs - sectors per track (26,26,15,8)
                ;    secLen - sector length (128,256,512,1024)
                ;    trkLen - track length
                ;--------------------------------------------------------------
 0852 CD27E0    dSecFmt	call	STATUS
 0855 1F        	rar			;sector length is bits 2-3
 0856 E606      	ani	06h		;a=2*length code
 0858 1600      	mvi	d,0		;de=2*length code (16 bit)
 085A 5F        	mov	e,a
                
 085B 217A08    	lxi	h,sptTbl	;set sectors per track
 085E 19        	dad	d		;index by length code
 085F 7E        	mov	a,m
 0860 329608    	sta	numSecs
                 
 0863 218208    	lxi	h,seclTbl	;set sector length
 0866 19        	dad	d		;index by length code
 0867 4E        	mov	c,m		;lsb
 0868 23        	inx	h
 0869 66        	mov	h,m		;msb
 086A 69        	mov	l,c		;hl=sector length
 086B 229408    	shld	secLen
                
 086E 218A08    	lxi	h,trklTbl	;set track length
 0871 19        	dad	d		;index by length code
 0872 4E        	mov	c,m		;lsb
 0873 23        	inx	h
 0874 66        	mov	h,m		;msb
 0875 69        	mov	l,c		;hl=track length
 0876 229708    	shld	trkLen
 0879 C9        	ret
                
 087A 1A001A000FsptTbl	dw	26, 26, 15, 8
 0882 8000000100seclTbl	dw	128, 256, 512, 1024
 088A 000D001A00trklTbl	dw	26*128, 26*256, 15*512, 8*1024
                
                ;**************************************************************************
                ; 
                ;  Data area
                ;
                ;**************************************************************************
                ; disk variables
                
 0892           drvNum	ds	1		;drive number to use
 0893           trkNum	ds	1		;track number to read
 0894           secLen	ds	2		;sector length
 0896           numSecs	ds	1		;number of sectors per track
 0897           trkLen	ds	2		;track length
 0899           trkPtr	ds	2		;pointer into trkBuf at track boundaries
 089B           bufEnd	ds	2		;end address + 1 of last track spot in RAM
                
                ; retry logic variables
                
 089D           rdRtry	ds	1		;disk read retry counter
 089E           rtStep	ds	1		;current retry step
 089F           trkErr	ds	1		;non zero if error occured on track
                
                ; xmodem variables
                
 08A0           xfrPort	ds	1		;pseudo port for file transfer
 08A1           xmRetry	ds	1		;xmodem retry counter
 08A2           blkNum	ds	1		;current xmodem block number
 08A3           crcFlag	ds	1		;non zero if using CRC instead of checksum
 08A4           crc16	ds	2		;crc-16 result
 08A6           sndPtr	ds	2		;pointer for start of XMODEM send
                
                ; misc variables
                
 08A8           cpmFlag	ds	1		;non-zero if running under CP/M
 08A9           baseDrv	ds	1		;ascii 1st drive - baseDrv = 0
 08AA           	ds	64		;stack space
 08EA =         ourStk	equ	$
                
                ; track buffer runs from here to the end of memory
                
 08EA           	ds	PKTLEN		;space for pre-pended unsent data
                
 096A =         trkBuf	equ	$
                
 096A           	end
